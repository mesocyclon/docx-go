// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_P ---

// CT_P â€” paragraph element
type CT_P struct {
	Element
}

// PPr returns the <w:pPr> child element, or nil if not present.
func (e *CT_P) PPr() *CT_PPr {
	child := e.FindChild("w:pPr")
	if child == nil {
		return nil
	}
	return &CT_PPr{Element{E: child}}
}

// GetOrAddPPr returns <w:pPr>, creating it if not present.
func (e *CT_P) GetOrAddPPr() *CT_PPr {
	child := e.PPr()
	if child != nil {
		return child
	}
	return e.addPPr()
}

// RemovePPr removes all <w:pPr> child elements.
func (e *CT_P) RemovePPr() {
	e.RemoveAll("w:pPr")
}

// addPPr adds a new <w:pPr> in correct sequence.
func (e *CT_P) addPPr() *CT_PPr {
	child := e.newPPr()
	e.insertPPr(child)
	return child
}

// newPPr creates a detached <w:pPr> element.
func (e *CT_P) newPPr() *CT_PPr {
	el := OxmlElement("w:pPr")
	return &CT_PPr{Element{E: el}}
}

// insertPPr inserts child before first successor.
func (e *CT_P) insertPPr(child *CT_PPr) *CT_PPr {
	e.InsertElementBefore(child.E, "w:hyperlink", "w:r")
	return child
}

// HyperlinkList returns all <w:hyperlink> child elements.
func (e *CT_P) HyperlinkList() []*CT_Hyperlink {
	children := e.FindAllChildren("w:hyperlink")
	result := make([]*CT_Hyperlink, len(children))
	for i, c := range children {
		result[i] = &CT_Hyperlink{Element{E: c}}
	}
	return result
}

// AddHyperlink adds a new <w:hyperlink> in correct sequence.
func (e *CT_P) AddHyperlink() *CT_Hyperlink {
	return e.addHyperlink()
}

// addHyperlink adds a new <w:hyperlink> unconditionally in correct sequence.
func (e *CT_P) addHyperlink() *CT_Hyperlink {
	child := e.newHyperlink()
	e.insertHyperlink(child)
	return child
}

// newHyperlink creates a detached <w:hyperlink> element.
func (e *CT_P) newHyperlink() *CT_Hyperlink {
	el := OxmlElement("w:hyperlink")
	return &CT_Hyperlink{Element{E: el}}
}

// insertHyperlink inserts child before first successor.
func (e *CT_P) insertHyperlink(child *CT_Hyperlink) *CT_Hyperlink {
	e.InsertElementBefore(child.E)
	return child
}

// RList returns all <w:r> child elements.
func (e *CT_P) RList() []*CT_R {
	children := e.FindAllChildren("w:r")
	result := make([]*CT_R, len(children))
	for i, c := range children {
		result[i] = &CT_R{Element{E: c}}
	}
	return result
}

// AddR adds a new <w:r> in correct sequence.
func (e *CT_P) AddR() *CT_R {
	return e.addR()
}

// addR adds a new <w:r> unconditionally in correct sequence.
func (e *CT_P) addR() *CT_R {
	child := e.newR()
	e.insertR(child)
	return child
}

// newR creates a detached <w:r> element.
func (e *CT_P) newR() *CT_R {
	el := OxmlElement("w:r")
	return &CT_R{Element{E: el}}
}

// insertR inserts child before first successor.
func (e *CT_P) insertR(child *CT_R) *CT_R {
	e.InsertElementBefore(child.E)
	return child
}
