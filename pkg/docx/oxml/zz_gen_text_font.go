// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_RPr ---

// CT_RPr — run properties element
type CT_RPr struct {
	Element
}

// RStyle returns the <w:rStyle> child element, or nil if not present.
func (e *CT_RPr) RStyle() *CT_String {
	child := e.FindChild("w:rStyle")
	if child == nil {
		return nil
	}
	return &CT_String{Element{E: child}}
}

// GetOrAddRStyle returns <w:rStyle>, creating it if not present.
func (e *CT_RPr) GetOrAddRStyle() *CT_String {
	child := e.RStyle()
	if child != nil {
		return child
	}
	return e.addRStyle()
}

// RemoveRStyle removes all <w:rStyle> child elements.
func (e *CT_RPr) RemoveRStyle() {
	e.RemoveAll("w:rStyle")
}

// addRStyle adds a new <w:rStyle> in correct sequence.
func (e *CT_RPr) addRStyle() *CT_String {
	child := e.newRStyle()
	e.insertRStyle(child)
	return child
}

// newRStyle creates a detached <w:rStyle> element.
func (e *CT_RPr) newRStyle() *CT_String {
	el := OxmlElement("w:rStyle")
	return &CT_String{Element{E: el}}
}

// insertRStyle inserts child before first successor.
func (e *CT_RPr) insertRStyle(child *CT_String) *CT_String {
	e.InsertElementBefore(child.E, "w:rFonts", "w:b", "w:bCs", "w:i", "w:iCs", "w:caps", "w:smallCaps", "w:strike", "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// RFonts returns the <w:rFonts> child element, or nil if not present.
func (e *CT_RPr) RFonts() *CT_Fonts {
	child := e.FindChild("w:rFonts")
	if child == nil {
		return nil
	}
	return &CT_Fonts{Element{E: child}}
}

// GetOrAddRFonts returns <w:rFonts>, creating it if not present.
func (e *CT_RPr) GetOrAddRFonts() *CT_Fonts {
	child := e.RFonts()
	if child != nil {
		return child
	}
	return e.addRFonts()
}

// RemoveRFonts removes all <w:rFonts> child elements.
func (e *CT_RPr) RemoveRFonts() {
	e.RemoveAll("w:rFonts")
}

// addRFonts adds a new <w:rFonts> in correct sequence.
func (e *CT_RPr) addRFonts() *CT_Fonts {
	child := e.newRFonts()
	e.insertRFonts(child)
	return child
}

// newRFonts creates a detached <w:rFonts> element.
func (e *CT_RPr) newRFonts() *CT_Fonts {
	el := OxmlElement("w:rFonts")
	return &CT_Fonts{Element{E: el}}
}

// insertRFonts inserts child before first successor.
func (e *CT_RPr) insertRFonts(child *CT_Fonts) *CT_Fonts {
	e.InsertElementBefore(child.E, "w:b", "w:bCs", "w:i", "w:iCs", "w:caps", "w:smallCaps", "w:strike", "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// B returns the <w:b> child element, or nil if not present.
func (e *CT_RPr) B() *CT_OnOff {
	child := e.FindChild("w:b")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddB returns <w:b>, creating it if not present.
func (e *CT_RPr) GetOrAddB() *CT_OnOff {
	child := e.B()
	if child != nil {
		return child
	}
	return e.addB()
}

// RemoveB removes all <w:b> child elements.
func (e *CT_RPr) RemoveB() {
	e.RemoveAll("w:b")
}

// addB adds a new <w:b> in correct sequence.
func (e *CT_RPr) addB() *CT_OnOff {
	child := e.newB()
	e.insertB(child)
	return child
}

// newB creates a detached <w:b> element.
func (e *CT_RPr) newB() *CT_OnOff {
	el := OxmlElement("w:b")
	return &CT_OnOff{Element{E: el}}
}

// insertB inserts child before first successor.
func (e *CT_RPr) insertB(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:bCs", "w:i", "w:iCs", "w:caps", "w:smallCaps", "w:strike", "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// BCs returns the <w:bCs> child element, or nil if not present.
func (e *CT_RPr) BCs() *CT_OnOff {
	child := e.FindChild("w:bCs")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddBCs returns <w:bCs>, creating it if not present.
func (e *CT_RPr) GetOrAddBCs() *CT_OnOff {
	child := e.BCs()
	if child != nil {
		return child
	}
	return e.addBCs()
}

// RemoveBCs removes all <w:bCs> child elements.
func (e *CT_RPr) RemoveBCs() {
	e.RemoveAll("w:bCs")
}

// addBCs adds a new <w:bCs> in correct sequence.
func (e *CT_RPr) addBCs() *CT_OnOff {
	child := e.newBCs()
	e.insertBCs(child)
	return child
}

// newBCs creates a detached <w:bCs> element.
func (e *CT_RPr) newBCs() *CT_OnOff {
	el := OxmlElement("w:bCs")
	return &CT_OnOff{Element{E: el}}
}

// insertBCs inserts child before first successor.
func (e *CT_RPr) insertBCs(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:i", "w:iCs", "w:caps", "w:smallCaps", "w:strike", "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// I returns the <w:i> child element, or nil if not present.
func (e *CT_RPr) I() *CT_OnOff {
	child := e.FindChild("w:i")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddI returns <w:i>, creating it if not present.
func (e *CT_RPr) GetOrAddI() *CT_OnOff {
	child := e.I()
	if child != nil {
		return child
	}
	return e.addI()
}

// RemoveI removes all <w:i> child elements.
func (e *CT_RPr) RemoveI() {
	e.RemoveAll("w:i")
}

// addI adds a new <w:i> in correct sequence.
func (e *CT_RPr) addI() *CT_OnOff {
	child := e.newI()
	e.insertI(child)
	return child
}

// newI creates a detached <w:i> element.
func (e *CT_RPr) newI() *CT_OnOff {
	el := OxmlElement("w:i")
	return &CT_OnOff{Element{E: el}}
}

// insertI inserts child before first successor.
func (e *CT_RPr) insertI(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:iCs", "w:caps", "w:smallCaps", "w:strike", "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// ICs returns the <w:iCs> child element, or nil if not present.
func (e *CT_RPr) ICs() *CT_OnOff {
	child := e.FindChild("w:iCs")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddICs returns <w:iCs>, creating it if not present.
func (e *CT_RPr) GetOrAddICs() *CT_OnOff {
	child := e.ICs()
	if child != nil {
		return child
	}
	return e.addICs()
}

// RemoveICs removes all <w:iCs> child elements.
func (e *CT_RPr) RemoveICs() {
	e.RemoveAll("w:iCs")
}

// addICs adds a new <w:iCs> in correct sequence.
func (e *CT_RPr) addICs() *CT_OnOff {
	child := e.newICs()
	e.insertICs(child)
	return child
}

// newICs creates a detached <w:iCs> element.
func (e *CT_RPr) newICs() *CT_OnOff {
	el := OxmlElement("w:iCs")
	return &CT_OnOff{Element{E: el}}
}

// insertICs inserts child before first successor.
func (e *CT_RPr) insertICs(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:caps", "w:smallCaps", "w:strike", "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Caps returns the <w:caps> child element, or nil if not present.
func (e *CT_RPr) Caps() *CT_OnOff {
	child := e.FindChild("w:caps")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddCaps returns <w:caps>, creating it if not present.
func (e *CT_RPr) GetOrAddCaps() *CT_OnOff {
	child := e.Caps()
	if child != nil {
		return child
	}
	return e.addCaps()
}

// RemoveCaps removes all <w:caps> child elements.
func (e *CT_RPr) RemoveCaps() {
	e.RemoveAll("w:caps")
}

// addCaps adds a new <w:caps> in correct sequence.
func (e *CT_RPr) addCaps() *CT_OnOff {
	child := e.newCaps()
	e.insertCaps(child)
	return child
}

// newCaps creates a detached <w:caps> element.
func (e *CT_RPr) newCaps() *CT_OnOff {
	el := OxmlElement("w:caps")
	return &CT_OnOff{Element{E: el}}
}

// insertCaps inserts child before first successor.
func (e *CT_RPr) insertCaps(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:smallCaps", "w:strike", "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// SmallCaps returns the <w:smallCaps> child element, or nil if not present.
func (e *CT_RPr) SmallCaps() *CT_OnOff {
	child := e.FindChild("w:smallCaps")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddSmallCaps returns <w:smallCaps>, creating it if not present.
func (e *CT_RPr) GetOrAddSmallCaps() *CT_OnOff {
	child := e.SmallCaps()
	if child != nil {
		return child
	}
	return e.addSmallCaps()
}

// RemoveSmallCaps removes all <w:smallCaps> child elements.
func (e *CT_RPr) RemoveSmallCaps() {
	e.RemoveAll("w:smallCaps")
}

// addSmallCaps adds a new <w:smallCaps> in correct sequence.
func (e *CT_RPr) addSmallCaps() *CT_OnOff {
	child := e.newSmallCaps()
	e.insertSmallCaps(child)
	return child
}

// newSmallCaps creates a detached <w:smallCaps> element.
func (e *CT_RPr) newSmallCaps() *CT_OnOff {
	el := OxmlElement("w:smallCaps")
	return &CT_OnOff{Element{E: el}}
}

// insertSmallCaps inserts child before first successor.
func (e *CT_RPr) insertSmallCaps(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:strike", "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Strike returns the <w:strike> child element, or nil if not present.
func (e *CT_RPr) Strike() *CT_OnOff {
	child := e.FindChild("w:strike")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddStrike returns <w:strike>, creating it if not present.
func (e *CT_RPr) GetOrAddStrike() *CT_OnOff {
	child := e.Strike()
	if child != nil {
		return child
	}
	return e.addStrike()
}

// RemoveStrike removes all <w:strike> child elements.
func (e *CT_RPr) RemoveStrike() {
	e.RemoveAll("w:strike")
}

// addStrike adds a new <w:strike> in correct sequence.
func (e *CT_RPr) addStrike() *CT_OnOff {
	child := e.newStrike()
	e.insertStrike(child)
	return child
}

// newStrike creates a detached <w:strike> element.
func (e *CT_RPr) newStrike() *CT_OnOff {
	el := OxmlElement("w:strike")
	return &CT_OnOff{Element{E: el}}
}

// insertStrike inserts child before first successor.
func (e *CT_RPr) insertStrike(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:dstrike", "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Dstrike returns the <w:dstrike> child element, or nil if not present.
func (e *CT_RPr) Dstrike() *CT_OnOff {
	child := e.FindChild("w:dstrike")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddDstrike returns <w:dstrike>, creating it if not present.
func (e *CT_RPr) GetOrAddDstrike() *CT_OnOff {
	child := e.Dstrike()
	if child != nil {
		return child
	}
	return e.addDstrike()
}

// RemoveDstrike removes all <w:dstrike> child elements.
func (e *CT_RPr) RemoveDstrike() {
	e.RemoveAll("w:dstrike")
}

// addDstrike adds a new <w:dstrike> in correct sequence.
func (e *CT_RPr) addDstrike() *CT_OnOff {
	child := e.newDstrike()
	e.insertDstrike(child)
	return child
}

// newDstrike creates a detached <w:dstrike> element.
func (e *CT_RPr) newDstrike() *CT_OnOff {
	el := OxmlElement("w:dstrike")
	return &CT_OnOff{Element{E: el}}
}

// insertDstrike inserts child before first successor.
func (e *CT_RPr) insertDstrike(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:outline", "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Outline returns the <w:outline> child element, or nil if not present.
func (e *CT_RPr) Outline() *CT_OnOff {
	child := e.FindChild("w:outline")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddOutline returns <w:outline>, creating it if not present.
func (e *CT_RPr) GetOrAddOutline() *CT_OnOff {
	child := e.Outline()
	if child != nil {
		return child
	}
	return e.addOutline()
}

// RemoveOutline removes all <w:outline> child elements.
func (e *CT_RPr) RemoveOutline() {
	e.RemoveAll("w:outline")
}

// addOutline adds a new <w:outline> in correct sequence.
func (e *CT_RPr) addOutline() *CT_OnOff {
	child := e.newOutline()
	e.insertOutline(child)
	return child
}

// newOutline creates a detached <w:outline> element.
func (e *CT_RPr) newOutline() *CT_OnOff {
	el := OxmlElement("w:outline")
	return &CT_OnOff{Element{E: el}}
}

// insertOutline inserts child before first successor.
func (e *CT_RPr) insertOutline(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:shadow", "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Shadow returns the <w:shadow> child element, or nil if not present.
func (e *CT_RPr) Shadow() *CT_OnOff {
	child := e.FindChild("w:shadow")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddShadow returns <w:shadow>, creating it if not present.
func (e *CT_RPr) GetOrAddShadow() *CT_OnOff {
	child := e.Shadow()
	if child != nil {
		return child
	}
	return e.addShadow()
}

// RemoveShadow removes all <w:shadow> child elements.
func (e *CT_RPr) RemoveShadow() {
	e.RemoveAll("w:shadow")
}

// addShadow adds a new <w:shadow> in correct sequence.
func (e *CT_RPr) addShadow() *CT_OnOff {
	child := e.newShadow()
	e.insertShadow(child)
	return child
}

// newShadow creates a detached <w:shadow> element.
func (e *CT_RPr) newShadow() *CT_OnOff {
	el := OxmlElement("w:shadow")
	return &CT_OnOff{Element{E: el}}
}

// insertShadow inserts child before first successor.
func (e *CT_RPr) insertShadow(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:emboss", "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Emboss returns the <w:emboss> child element, or nil if not present.
func (e *CT_RPr) Emboss() *CT_OnOff {
	child := e.FindChild("w:emboss")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddEmboss returns <w:emboss>, creating it if not present.
func (e *CT_RPr) GetOrAddEmboss() *CT_OnOff {
	child := e.Emboss()
	if child != nil {
		return child
	}
	return e.addEmboss()
}

// RemoveEmboss removes all <w:emboss> child elements.
func (e *CT_RPr) RemoveEmboss() {
	e.RemoveAll("w:emboss")
}

// addEmboss adds a new <w:emboss> in correct sequence.
func (e *CT_RPr) addEmboss() *CT_OnOff {
	child := e.newEmboss()
	e.insertEmboss(child)
	return child
}

// newEmboss creates a detached <w:emboss> element.
func (e *CT_RPr) newEmboss() *CT_OnOff {
	el := OxmlElement("w:emboss")
	return &CT_OnOff{Element{E: el}}
}

// insertEmboss inserts child before first successor.
func (e *CT_RPr) insertEmboss(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:imprint", "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Imprint returns the <w:imprint> child element, or nil if not present.
func (e *CT_RPr) Imprint() *CT_OnOff {
	child := e.FindChild("w:imprint")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddImprint returns <w:imprint>, creating it if not present.
func (e *CT_RPr) GetOrAddImprint() *CT_OnOff {
	child := e.Imprint()
	if child != nil {
		return child
	}
	return e.addImprint()
}

// RemoveImprint removes all <w:imprint> child elements.
func (e *CT_RPr) RemoveImprint() {
	e.RemoveAll("w:imprint")
}

// addImprint adds a new <w:imprint> in correct sequence.
func (e *CT_RPr) addImprint() *CT_OnOff {
	child := e.newImprint()
	e.insertImprint(child)
	return child
}

// newImprint creates a detached <w:imprint> element.
func (e *CT_RPr) newImprint() *CT_OnOff {
	el := OxmlElement("w:imprint")
	return &CT_OnOff{Element{E: el}}
}

// insertImprint inserts child before first successor.
func (e *CT_RPr) insertImprint(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:noProof", "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// NoProof returns the <w:noProof> child element, or nil if not present.
func (e *CT_RPr) NoProof() *CT_OnOff {
	child := e.FindChild("w:noProof")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddNoProof returns <w:noProof>, creating it if not present.
func (e *CT_RPr) GetOrAddNoProof() *CT_OnOff {
	child := e.NoProof()
	if child != nil {
		return child
	}
	return e.addNoProof()
}

// RemoveNoProof removes all <w:noProof> child elements.
func (e *CT_RPr) RemoveNoProof() {
	e.RemoveAll("w:noProof")
}

// addNoProof adds a new <w:noProof> in correct sequence.
func (e *CT_RPr) addNoProof() *CT_OnOff {
	child := e.newNoProof()
	e.insertNoProof(child)
	return child
}

// newNoProof creates a detached <w:noProof> element.
func (e *CT_RPr) newNoProof() *CT_OnOff {
	el := OxmlElement("w:noProof")
	return &CT_OnOff{Element{E: el}}
}

// insertNoProof inserts child before first successor.
func (e *CT_RPr) insertNoProof(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:snapToGrid", "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// SnapToGrid returns the <w:snapToGrid> child element, or nil if not present.
func (e *CT_RPr) SnapToGrid() *CT_OnOff {
	child := e.FindChild("w:snapToGrid")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddSnapToGrid returns <w:snapToGrid>, creating it if not present.
func (e *CT_RPr) GetOrAddSnapToGrid() *CT_OnOff {
	child := e.SnapToGrid()
	if child != nil {
		return child
	}
	return e.addSnapToGrid()
}

// RemoveSnapToGrid removes all <w:snapToGrid> child elements.
func (e *CT_RPr) RemoveSnapToGrid() {
	e.RemoveAll("w:snapToGrid")
}

// addSnapToGrid adds a new <w:snapToGrid> in correct sequence.
func (e *CT_RPr) addSnapToGrid() *CT_OnOff {
	child := e.newSnapToGrid()
	e.insertSnapToGrid(child)
	return child
}

// newSnapToGrid creates a detached <w:snapToGrid> element.
func (e *CT_RPr) newSnapToGrid() *CT_OnOff {
	el := OxmlElement("w:snapToGrid")
	return &CT_OnOff{Element{E: el}}
}

// insertSnapToGrid inserts child before first successor.
func (e *CT_RPr) insertSnapToGrid(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:vanish", "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Vanish returns the <w:vanish> child element, or nil if not present.
func (e *CT_RPr) Vanish() *CT_OnOff {
	child := e.FindChild("w:vanish")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddVanish returns <w:vanish>, creating it if not present.
func (e *CT_RPr) GetOrAddVanish() *CT_OnOff {
	child := e.Vanish()
	if child != nil {
		return child
	}
	return e.addVanish()
}

// RemoveVanish removes all <w:vanish> child elements.
func (e *CT_RPr) RemoveVanish() {
	e.RemoveAll("w:vanish")
}

// addVanish adds a new <w:vanish> in correct sequence.
func (e *CT_RPr) addVanish() *CT_OnOff {
	child := e.newVanish()
	e.insertVanish(child)
	return child
}

// newVanish creates a detached <w:vanish> element.
func (e *CT_RPr) newVanish() *CT_OnOff {
	el := OxmlElement("w:vanish")
	return &CT_OnOff{Element{E: el}}
}

// insertVanish inserts child before first successor.
func (e *CT_RPr) insertVanish(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:webHidden", "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// WebHidden returns the <w:webHidden> child element, or nil if not present.
func (e *CT_RPr) WebHidden() *CT_OnOff {
	child := e.FindChild("w:webHidden")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddWebHidden returns <w:webHidden>, creating it if not present.
func (e *CT_RPr) GetOrAddWebHidden() *CT_OnOff {
	child := e.WebHidden()
	if child != nil {
		return child
	}
	return e.addWebHidden()
}

// RemoveWebHidden removes all <w:webHidden> child elements.
func (e *CT_RPr) RemoveWebHidden() {
	e.RemoveAll("w:webHidden")
}

// addWebHidden adds a new <w:webHidden> in correct sequence.
func (e *CT_RPr) addWebHidden() *CT_OnOff {
	child := e.newWebHidden()
	e.insertWebHidden(child)
	return child
}

// newWebHidden creates a detached <w:webHidden> element.
func (e *CT_RPr) newWebHidden() *CT_OnOff {
	el := OxmlElement("w:webHidden")
	return &CT_OnOff{Element{E: el}}
}

// insertWebHidden inserts child before first successor.
func (e *CT_RPr) insertWebHidden(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:color", "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Color returns the <w:color> child element, or nil if not present.
func (e *CT_RPr) Color() *CT_Color {
	child := e.FindChild("w:color")
	if child == nil {
		return nil
	}
	return &CT_Color{Element{E: child}}
}

// GetOrAddColor returns <w:color>, creating it if not present.
func (e *CT_RPr) GetOrAddColor() *CT_Color {
	child := e.Color()
	if child != nil {
		return child
	}
	return e.addColor()
}

// RemoveColor removes all <w:color> child elements.
func (e *CT_RPr) RemoveColor() {
	e.RemoveAll("w:color")
}

// addColor adds a new <w:color> in correct sequence.
func (e *CT_RPr) addColor() *CT_Color {
	child := e.newColor()
	e.insertColor(child)
	return child
}

// newColor creates a detached <w:color> element.
func (e *CT_RPr) newColor() *CT_Color {
	el := OxmlElement("w:color")
	return &CT_Color{Element{E: el}}
}

// insertColor inserts child before first successor.
func (e *CT_RPr) insertColor(child *CT_Color) *CT_Color {
	e.InsertElementBefore(child.E, "w:spacing", "w:w", "w:kern", "w:position", "w:sz", "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Sz returns the <w:sz> child element, or nil if not present.
func (e *CT_RPr) Sz() *CT_HpsMeasure {
	child := e.FindChild("w:sz")
	if child == nil {
		return nil
	}
	return &CT_HpsMeasure{Element{E: child}}
}

// GetOrAddSz returns <w:sz>, creating it if not present.
func (e *CT_RPr) GetOrAddSz() *CT_HpsMeasure {
	child := e.Sz()
	if child != nil {
		return child
	}
	return e.addSz()
}

// RemoveSz removes all <w:sz> child elements.
func (e *CT_RPr) RemoveSz() {
	e.RemoveAll("w:sz")
}

// addSz adds a new <w:sz> in correct sequence.
func (e *CT_RPr) addSz() *CT_HpsMeasure {
	child := e.newSz()
	e.insertSz(child)
	return child
}

// newSz creates a detached <w:sz> element.
func (e *CT_RPr) newSz() *CT_HpsMeasure {
	el := OxmlElement("w:sz")
	return &CT_HpsMeasure{Element{E: el}}
}

// insertSz inserts child before first successor.
func (e *CT_RPr) insertSz(child *CT_HpsMeasure) *CT_HpsMeasure {
	e.InsertElementBefore(child.E, "w:szCs", "w:highlight", "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Highlight returns the <w:highlight> child element, or nil if not present.
func (e *CT_RPr) Highlight() *CT_Highlight {
	child := e.FindChild("w:highlight")
	if child == nil {
		return nil
	}
	return &CT_Highlight{Element{E: child}}
}

// GetOrAddHighlight returns <w:highlight>, creating it if not present.
func (e *CT_RPr) GetOrAddHighlight() *CT_Highlight {
	child := e.Highlight()
	if child != nil {
		return child
	}
	return e.addHighlight()
}

// RemoveHighlight removes all <w:highlight> child elements.
func (e *CT_RPr) RemoveHighlight() {
	e.RemoveAll("w:highlight")
}

// addHighlight adds a new <w:highlight> in correct sequence.
func (e *CT_RPr) addHighlight() *CT_Highlight {
	child := e.newHighlight()
	e.insertHighlight(child)
	return child
}

// newHighlight creates a detached <w:highlight> element.
func (e *CT_RPr) newHighlight() *CT_Highlight {
	el := OxmlElement("w:highlight")
	return &CT_Highlight{Element{E: el}}
}

// insertHighlight inserts child before first successor.
func (e *CT_RPr) insertHighlight(child *CT_Highlight) *CT_Highlight {
	e.InsertElementBefore(child.E, "w:u", "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// U returns the <w:u> child element, or nil if not present.
func (e *CT_RPr) U() *CT_Underline {
	child := e.FindChild("w:u")
	if child == nil {
		return nil
	}
	return &CT_Underline{Element{E: child}}
}

// GetOrAddU returns <w:u>, creating it if not present.
func (e *CT_RPr) GetOrAddU() *CT_Underline {
	child := e.U()
	if child != nil {
		return child
	}
	return e.addU()
}

// RemoveU removes all <w:u> child elements.
func (e *CT_RPr) RemoveU() {
	e.RemoveAll("w:u")
}

// addU adds a new <w:u> in correct sequence.
func (e *CT_RPr) addU() *CT_Underline {
	child := e.newU()
	e.insertU(child)
	return child
}

// newU creates a detached <w:u> element.
func (e *CT_RPr) newU() *CT_Underline {
	el := OxmlElement("w:u")
	return &CT_Underline{Element{E: el}}
}

// insertU inserts child before first successor.
func (e *CT_RPr) insertU(child *CT_Underline) *CT_Underline {
	e.InsertElementBefore(child.E, "w:effect", "w:bdr", "w:shd", "w:fitText", "w:vertAlign", "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// VertAlign returns the <w:vertAlign> child element, or nil if not present.
func (e *CT_RPr) VertAlign() *CT_VerticalAlignRun {
	child := e.FindChild("w:vertAlign")
	if child == nil {
		return nil
	}
	return &CT_VerticalAlignRun{Element{E: child}}
}

// GetOrAddVertAlign returns <w:vertAlign>, creating it if not present.
func (e *CT_RPr) GetOrAddVertAlign() *CT_VerticalAlignRun {
	child := e.VertAlign()
	if child != nil {
		return child
	}
	return e.addVertAlign()
}

// RemoveVertAlign removes all <w:vertAlign> child elements.
func (e *CT_RPr) RemoveVertAlign() {
	e.RemoveAll("w:vertAlign")
}

// addVertAlign adds a new <w:vertAlign> in correct sequence.
func (e *CT_RPr) addVertAlign() *CT_VerticalAlignRun {
	child := e.newVertAlign()
	e.insertVertAlign(child)
	return child
}

// newVertAlign creates a detached <w:vertAlign> element.
func (e *CT_RPr) newVertAlign() *CT_VerticalAlignRun {
	el := OxmlElement("w:vertAlign")
	return &CT_VerticalAlignRun{Element{E: el}}
}

// insertVertAlign inserts child before first successor.
func (e *CT_RPr) insertVertAlign(child *CT_VerticalAlignRun) *CT_VerticalAlignRun {
	e.InsertElementBefore(child.E, "w:rtl", "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Rtl returns the <w:rtl> child element, or nil if not present.
func (e *CT_RPr) Rtl() *CT_OnOff {
	child := e.FindChild("w:rtl")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddRtl returns <w:rtl>, creating it if not present.
func (e *CT_RPr) GetOrAddRtl() *CT_OnOff {
	child := e.Rtl()
	if child != nil {
		return child
	}
	return e.addRtl()
}

// RemoveRtl removes all <w:rtl> child elements.
func (e *CT_RPr) RemoveRtl() {
	e.RemoveAll("w:rtl")
}

// addRtl adds a new <w:rtl> in correct sequence.
func (e *CT_RPr) addRtl() *CT_OnOff {
	child := e.newRtl()
	e.insertRtl(child)
	return child
}

// newRtl creates a detached <w:rtl> element.
func (e *CT_RPr) newRtl() *CT_OnOff {
	el := OxmlElement("w:rtl")
	return &CT_OnOff{Element{E: el}}
}

// insertRtl inserts child before first successor.
func (e *CT_RPr) insertRtl(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:cs", "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// Cs returns the <w:cs> child element, or nil if not present.
func (e *CT_RPr) Cs() *CT_OnOff {
	child := e.FindChild("w:cs")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddCs returns <w:cs>, creating it if not present.
func (e *CT_RPr) GetOrAddCs() *CT_OnOff {
	child := e.Cs()
	if child != nil {
		return child
	}
	return e.addCs()
}

// RemoveCs removes all <w:cs> child elements.
func (e *CT_RPr) RemoveCs() {
	e.RemoveAll("w:cs")
}

// addCs adds a new <w:cs> in correct sequence.
func (e *CT_RPr) addCs() *CT_OnOff {
	child := e.newCs()
	e.insertCs(child)
	return child
}

// newCs creates a detached <w:cs> element.
func (e *CT_RPr) newCs() *CT_OnOff {
	el := OxmlElement("w:cs")
	return &CT_OnOff{Element{E: el}}
}

// insertCs inserts child before first successor.
func (e *CT_RPr) insertCs(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:em", "w:lang", "w:eastAsianLayout", "w:specVanish", "w:oMath")
	return child
}

// SpecVanish returns the <w:specVanish> child element, or nil if not present.
func (e *CT_RPr) SpecVanish() *CT_OnOff {
	child := e.FindChild("w:specVanish")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddSpecVanish returns <w:specVanish>, creating it if not present.
func (e *CT_RPr) GetOrAddSpecVanish() *CT_OnOff {
	child := e.SpecVanish()
	if child != nil {
		return child
	}
	return e.addSpecVanish()
}

// RemoveSpecVanish removes all <w:specVanish> child elements.
func (e *CT_RPr) RemoveSpecVanish() {
	e.RemoveAll("w:specVanish")
}

// addSpecVanish adds a new <w:specVanish> in correct sequence.
func (e *CT_RPr) addSpecVanish() *CT_OnOff {
	child := e.newSpecVanish()
	e.insertSpecVanish(child)
	return child
}

// newSpecVanish creates a detached <w:specVanish> element.
func (e *CT_RPr) newSpecVanish() *CT_OnOff {
	el := OxmlElement("w:specVanish")
	return &CT_OnOff{Element{E: el}}
}

// insertSpecVanish inserts child before first successor.
func (e *CT_RPr) insertSpecVanish(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:oMath")
	return child
}

// OMath returns the <w:oMath> child element, or nil if not present.
func (e *CT_RPr) OMath() *CT_OnOff {
	child := e.FindChild("w:oMath")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddOMath returns <w:oMath>, creating it if not present.
func (e *CT_RPr) GetOrAddOMath() *CT_OnOff {
	child := e.OMath()
	if child != nil {
		return child
	}
	return e.addOMath()
}

// RemoveOMath removes all <w:oMath> child elements.
func (e *CT_RPr) RemoveOMath() {
	e.RemoveAll("w:oMath")
}

// addOMath adds a new <w:oMath> in correct sequence.
func (e *CT_RPr) addOMath() *CT_OnOff {
	child := e.newOMath()
	e.insertOMath(child)
	return child
}

// newOMath creates a detached <w:oMath> element.
func (e *CT_RPr) newOMath() *CT_OnOff {
	el := OxmlElement("w:oMath")
	return &CT_OnOff{Element{E: el}}
}

// insertOMath inserts child before first successor.
func (e *CT_RPr) insertOMath(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_Color ---

// CT_Color — color element
type CT_Color struct {
	Element
}

// ThemeColor returns the value of the "w:themeColor" attribute, or "" if absent.
func (e *CT_Color) ThemeColor() string {
	val, ok := e.GetAttr("w:themeColor")
	if !ok {
		return ""
	}
	return val
}

// SetThemeColor sets the "w:themeColor" attribute.
// Passing "" removes it.
func (e *CT_Color) SetThemeColor(v string) {
	if v == "" {
		e.RemoveAttr("w:themeColor")
		return
	}
	e.SetAttr("w:themeColor", v)
}

// Val returns the value of the required "w:val" attribute.
func (e *CT_Color) Val() (string, error) {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return "", fmt.Errorf("required attribute %q not present on <%s>", "w:val", e.Tag())
	}
	return val, nil
}

// SetVal sets the required "w:val" attribute.
func (e *CT_Color) SetVal(v string) {
	e.SetAttr("w:val", v)
}

// --- CT_Fonts ---

// CT_Fonts — run fonts element
type CT_Fonts struct {
	Element
}

// Ascii returns the value of the "w:ascii" attribute, or "" if absent.
func (e *CT_Fonts) Ascii() string {
	val, ok := e.GetAttr("w:ascii")
	if !ok {
		return ""
	}
	return val
}

// SetAscii sets the "w:ascii" attribute.
// Passing "" removes it.
func (e *CT_Fonts) SetAscii(v string) {
	if v == "" {
		e.RemoveAttr("w:ascii")
		return
	}
	e.SetAttr("w:ascii", v)
}

// HAnsi returns the value of the "w:hAnsi" attribute, or "" if absent.
func (e *CT_Fonts) HAnsi() string {
	val, ok := e.GetAttr("w:hAnsi")
	if !ok {
		return ""
	}
	return val
}

// SetHAnsi sets the "w:hAnsi" attribute.
// Passing "" removes it.
func (e *CT_Fonts) SetHAnsi(v string) {
	if v == "" {
		e.RemoveAttr("w:hAnsi")
		return
	}
	e.SetAttr("w:hAnsi", v)
}

// --- CT_Highlight ---

// CT_Highlight — highlight color element
type CT_Highlight struct {
	Element
}

// Val returns the value of the required "w:val" attribute.
func (e *CT_Highlight) Val() (string, error) {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return "", fmt.Errorf("required attribute %q not present on <%s>", "w:val", e.Tag())
	}
	return val, nil
}

// SetVal sets the required "w:val" attribute.
func (e *CT_Highlight) SetVal(v string) {
	e.SetAttr("w:val", v)
}

// --- CT_HpsMeasure ---

// CT_HpsMeasure — half-point size measure element
type CT_HpsMeasure struct {
	Element
}

// Val returns the value of the required "w:val" attribute.
func (e *CT_HpsMeasure) Val() (int64, error) {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return 0, fmt.Errorf("required attribute %q not present on <%s>", "w:val", e.Tag())
	}
	return parseInt64Attr(val), nil
}

// SetVal sets the required "w:val" attribute.
func (e *CT_HpsMeasure) SetVal(v int64) {
	e.SetAttr("w:val", formatInt64Attr(v))
}

// --- CT_Underline ---

// CT_Underline — underline element
type CT_Underline struct {
	Element
}

// Val returns the value of the "w:val" attribute, or "" if absent.
func (e *CT_Underline) Val() string {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return ""
	}
	return val
}

// SetVal sets the "w:val" attribute.
// Passing "" removes it.
func (e *CT_Underline) SetVal(v string) {
	if v == "" {
		e.RemoveAttr("w:val")
		return
	}
	e.SetAttr("w:val", v)
}

// --- CT_VerticalAlignRun ---

// CT_VerticalAlignRun — vertical align run element
type CT_VerticalAlignRun struct {
	Element
}

// Val returns the value of the required "w:val" attribute.
func (e *CT_VerticalAlignRun) Val() (string, error) {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return "", fmt.Errorf("required attribute %q not present on <%s>", "w:val", e.Tag())
	}
	return val, nil
}

// SetVal sets the required "w:val" attribute.
func (e *CT_VerticalAlignRun) SetVal(v string) {
	e.SetAttr("w:val", v)
}
