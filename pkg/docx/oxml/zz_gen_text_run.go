// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_R ---

// CT_R — run element
type CT_R struct {
	Element
}

// RPr returns the <w:rPr> child element, or nil if not present.
func (e *CT_R) RPr() *CT_RPr {
	child := e.FindChild("w:rPr")
	if child == nil {
		return nil
	}
	return &CT_RPr{Element{E: child}}
}

// GetOrAddRPr returns <w:rPr>, creating it if not present.
func (e *CT_R) GetOrAddRPr() *CT_RPr {
	child := e.RPr()
	if child != nil {
		return child
	}
	return e.addRPr()
}

// RemoveRPr removes all <w:rPr> child elements.
func (e *CT_R) RemoveRPr() {
	e.RemoveAll("w:rPr")
}

// addRPr adds a new <w:rPr> in correct sequence.
func (e *CT_R) addRPr() *CT_RPr {
	child := e.newRPr()
	e.insertRPr(child)
	return child
}

// newRPr creates a detached <w:rPr> element.
func (e *CT_R) newRPr() *CT_RPr {
	el := OxmlElement("w:rPr")
	return &CT_RPr{Element{E: el}}
}

// insertRPr inserts child before first successor.
func (e *CT_R) insertRPr(child *CT_RPr) *CT_RPr {
	e.InsertElementBefore(child.E, "w:br", "w:cr", "w:drawing", "w:noBreakHyphen", "w:ptab", "w:t", "w:tab")
	return child
}

// BrList returns all <w:br> child elements.
func (e *CT_R) BrList() []*CT_Br {
	children := e.FindAllChildren("w:br")
	result := make([]*CT_Br, len(children))
	for i, c := range children {
		result[i] = &CT_Br{Element{E: c}}
	}
	return result
}

// AddBr adds a new <w:br> in correct sequence.
func (e *CT_R) AddBr() *CT_Br {
	return e.addBr()
}

// addBr adds a new <w:br> unconditionally in correct sequence.
func (e *CT_R) addBr() *CT_Br {
	child := e.newBr()
	e.insertBr(child)
	return child
}

// newBr creates a detached <w:br> element.
func (e *CT_R) newBr() *CT_Br {
	el := OxmlElement("w:br")
	return &CT_Br{Element{E: el}}
}

// insertBr inserts child before first successor.
func (e *CT_R) insertBr(child *CT_Br) *CT_Br {
	e.InsertElementBefore(child.E)
	return child
}

// CrList returns all <w:cr> child elements.
func (e *CT_R) CrList() []*CT_Cr {
	children := e.FindAllChildren("w:cr")
	result := make([]*CT_Cr, len(children))
	for i, c := range children {
		result[i] = &CT_Cr{Element{E: c}}
	}
	return result
}

// AddCr adds a new <w:cr> in correct sequence.
func (e *CT_R) AddCr() *CT_Cr {
	return e.addCr()
}

// addCr adds a new <w:cr> unconditionally in correct sequence.
func (e *CT_R) addCr() *CT_Cr {
	child := e.newCr()
	e.insertCr(child)
	return child
}

// newCr creates a detached <w:cr> element.
func (e *CT_R) newCr() *CT_Cr {
	el := OxmlElement("w:cr")
	return &CT_Cr{Element{E: el}}
}

// insertCr inserts child before first successor.
func (e *CT_R) insertCr(child *CT_Cr) *CT_Cr {
	e.InsertElementBefore(child.E)
	return child
}

// DrawingList returns all <w:drawing> child elements.
func (e *CT_R) DrawingList() []*CT_Drawing {
	children := e.FindAllChildren("w:drawing")
	result := make([]*CT_Drawing, len(children))
	for i, c := range children {
		result[i] = &CT_Drawing{Element{E: c}}
	}
	return result
}

// AddDrawing adds a new <w:drawing> in correct sequence.
func (e *CT_R) AddDrawing() *CT_Drawing {
	return e.addDrawing()
}

// addDrawing adds a new <w:drawing> unconditionally in correct sequence.
func (e *CT_R) addDrawing() *CT_Drawing {
	child := e.newDrawing()
	e.insertDrawing(child)
	return child
}

// newDrawing creates a detached <w:drawing> element.
func (e *CT_R) newDrawing() *CT_Drawing {
	el := OxmlElement("w:drawing")
	return &CT_Drawing{Element{E: el}}
}

// insertDrawing inserts child before first successor.
func (e *CT_R) insertDrawing(child *CT_Drawing) *CT_Drawing {
	e.InsertElementBefore(child.E)
	return child
}

// TList returns all <w:t> child elements.
func (e *CT_R) TList() []*CT_Text {
	children := e.FindAllChildren("w:t")
	result := make([]*CT_Text, len(children))
	for i, c := range children {
		result[i] = &CT_Text{Element{E: c}}
	}
	return result
}

// AddT adds a new <w:t> in correct sequence.
func (e *CT_R) AddT() *CT_Text {
	return e.addT()
}

// addT adds a new <w:t> unconditionally in correct sequence.
func (e *CT_R) addT() *CT_Text {
	child := e.newT()
	e.insertT(child)
	return child
}

// newT creates a detached <w:t> element.
func (e *CT_R) newT() *CT_Text {
	el := OxmlElement("w:t")
	return &CT_Text{Element{E: el}}
}

// insertT inserts child before first successor.
func (e *CT_R) insertT(child *CT_Text) *CT_Text {
	e.InsertElementBefore(child.E)
	return child
}

// TabList returns all <w:tab> child elements.
func (e *CT_R) TabList() []*CT_TabStop {
	children := e.FindAllChildren("w:tab")
	result := make([]*CT_TabStop, len(children))
	for i, c := range children {
		result[i] = &CT_TabStop{Element{E: c}}
	}
	return result
}

// AddTab adds a new <w:tab> in correct sequence.
func (e *CT_R) AddTab() *CT_TabStop {
	return e.addTab()
}

// addTab adds a new <w:tab> unconditionally in correct sequence.
func (e *CT_R) addTab() *CT_TabStop {
	child := e.newTab()
	e.insertTab(child)
	return child
}

// newTab creates a detached <w:tab> element.
func (e *CT_R) newTab() *CT_TabStop {
	el := OxmlElement("w:tab")
	return &CT_TabStop{Element{E: el}}
}

// insertTab inserts child before first successor.
func (e *CT_R) insertTab(child *CT_TabStop) *CT_TabStop {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_Br ---

// CT_Br — break element
type CT_Br struct {
	Element
}

// Type returns the value of the "w:type" attribute, or "textWrapping" if absent.
func (e *CT_Br) Type() string {
	val, ok := e.GetAttr("w:type")
	if !ok {
		return "textWrapping"
	}
	return val
}

// SetType sets the "w:type" attribute.
// Passing "textWrapping" removes it.
func (e *CT_Br) SetType(v string) {
	if v == "textWrapping" {
		e.RemoveAttr("w:type")
		return
	}
	e.SetAttr("w:type", v)
}

// Clear returns the value of the "w:clear" attribute, or "" if absent.
func (e *CT_Br) Clear() string {
	val, ok := e.GetAttr("w:clear")
	if !ok {
		return ""
	}
	return val
}

// SetClear sets the "w:clear" attribute.
// Passing "" removes it.
func (e *CT_Br) SetClear(v string) {
	if v == "" {
		e.RemoveAttr("w:clear")
		return
	}
	e.SetAttr("w:clear", v)
}

// --- CT_Cr ---

// CT_Cr — carriage return element
type CT_Cr struct {
	Element
}

// --- CT_NoBreakHyphen ---

// CT_NoBreakHyphen — non-breaking hyphen element
type CT_NoBreakHyphen struct {
	Element
}

// --- CT_PTab ---

// CT_PTab — absolute position tab element
type CT_PTab struct {
	Element
}

// --- CT_Text ---

// CT_Text — text element
type CT_Text struct {
	Element
}
