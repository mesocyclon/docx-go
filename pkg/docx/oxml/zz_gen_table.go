// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
	"github.com/user/go-docx/pkg/docx/enum"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_Tbl ---

// CT_Tbl — table element
type CT_Tbl struct {
	Element
}

// TrList returns all <w:tr> child elements.
func (e *CT_Tbl) TrList() []*CT_Row {
	children := e.FindAllChildren("w:tr")
	result := make([]*CT_Row, len(children))
	for i, c := range children {
		result[i] = &CT_Row{Element{E: c}}
	}
	return result
}

// AddTr adds a new <w:tr> in correct sequence.
func (e *CT_Tbl) AddTr() *CT_Row {
	return e.addTr()
}

// addTr adds a new <w:tr> unconditionally in correct sequence.
func (e *CT_Tbl) addTr() *CT_Row {
	child := e.newTr()
	e.insertTr(child)
	return child
}

// newTr creates a detached <w:tr> element.
func (e *CT_Tbl) newTr() *CT_Row {
	el := OxmlElement("w:tr")
	return &CT_Row{Element{E: el}}
}

// insertTr inserts child before first successor.
func (e *CT_Tbl) insertTr(child *CT_Row) *CT_Row {
	e.InsertElementBefore(child.E)
	return child
}

// TblPr returns the required <w:tblPr> child element.
// Panics if not present (invalid XML).
func (e *CT_Tbl) TblPr() *CT_TblPr {
	child := e.FindChild("w:tblPr")
	if child == nil {
		panic(fmt.Sprintf("required <%s> child not present in <%s>", "w:tblPr", e.Tag()))
	}
	return &CT_TblPr{Element{E: child}}
}

// TblGrid returns the required <w:tblGrid> child element.
// Panics if not present (invalid XML).
func (e *CT_Tbl) TblGrid() *CT_TblGrid {
	child := e.FindChild("w:tblGrid")
	if child == nil {
		panic(fmt.Sprintf("required <%s> child not present in <%s>", "w:tblGrid", e.Tag()))
	}
	return &CT_TblGrid{Element{E: child}}
}

// --- CT_Row ---

// CT_Row — table row element
type CT_Row struct {
	Element
}

// TblPrEx returns the <w:tblPrEx> child element, or nil if not present.
func (e *CT_Row) TblPrEx() *CT_TblPrEx {
	child := e.FindChild("w:tblPrEx")
	if child == nil {
		return nil
	}
	return &CT_TblPrEx{Element{E: child}}
}

// GetOrAddTblPrEx returns <w:tblPrEx>, creating it if not present.
func (e *CT_Row) GetOrAddTblPrEx() *CT_TblPrEx {
	child := e.TblPrEx()
	if child != nil {
		return child
	}
	return e.addTblPrEx()
}

// RemoveTblPrEx removes all <w:tblPrEx> child elements.
func (e *CT_Row) RemoveTblPrEx() {
	e.RemoveAll("w:tblPrEx")
}

// addTblPrEx adds a new <w:tblPrEx> in correct sequence.
func (e *CT_Row) addTblPrEx() *CT_TblPrEx {
	child := e.newTblPrEx()
	e.insertTblPrEx(child)
	return child
}

// newTblPrEx creates a detached <w:tblPrEx> element.
func (e *CT_Row) newTblPrEx() *CT_TblPrEx {
	el := OxmlElement("w:tblPrEx")
	return &CT_TblPrEx{Element{E: el}}
}

// insertTblPrEx inserts child before first successor.
func (e *CT_Row) insertTblPrEx(child *CT_TblPrEx) *CT_TblPrEx {
	e.InsertElementBefore(child.E, "w:trPr", "w:tc")
	return child
}

// TrPr returns the <w:trPr> child element, or nil if not present.
func (e *CT_Row) TrPr() *CT_TrPr {
	child := e.FindChild("w:trPr")
	if child == nil {
		return nil
	}
	return &CT_TrPr{Element{E: child}}
}

// GetOrAddTrPr returns <w:trPr>, creating it if not present.
func (e *CT_Row) GetOrAddTrPr() *CT_TrPr {
	child := e.TrPr()
	if child != nil {
		return child
	}
	return e.addTrPr()
}

// RemoveTrPr removes all <w:trPr> child elements.
func (e *CT_Row) RemoveTrPr() {
	e.RemoveAll("w:trPr")
}

// addTrPr adds a new <w:trPr> in correct sequence.
func (e *CT_Row) addTrPr() *CT_TrPr {
	child := e.newTrPr()
	e.insertTrPr(child)
	return child
}

// newTrPr creates a detached <w:trPr> element.
func (e *CT_Row) newTrPr() *CT_TrPr {
	el := OxmlElement("w:trPr")
	return &CT_TrPr{Element{E: el}}
}

// insertTrPr inserts child before first successor.
func (e *CT_Row) insertTrPr(child *CT_TrPr) *CT_TrPr {
	e.InsertElementBefore(child.E, "w:tc")
	return child
}

// TcList returns all <w:tc> child elements.
func (e *CT_Row) TcList() []*CT_Tc {
	children := e.FindAllChildren("w:tc")
	result := make([]*CT_Tc, len(children))
	for i, c := range children {
		result[i] = &CT_Tc{Element{E: c}}
	}
	return result
}

// AddTc adds a new <w:tc> in correct sequence.
func (e *CT_Row) AddTc() *CT_Tc {
	return e.addTc()
}

// addTc adds a new <w:tc> unconditionally in correct sequence.
func (e *CT_Row) addTc() *CT_Tc {
	child := e.newTc()
	e.insertTc(child)
	return child
}

// newTc creates a detached <w:tc> element.
func (e *CT_Row) newTc() *CT_Tc {
	el := OxmlElement("w:tc")
	return &CT_Tc{Element{E: el}}
}

// insertTc inserts child before first successor.
func (e *CT_Row) insertTc(child *CT_Tc) *CT_Tc {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_Tc ---

// CT_Tc — table cell element
type CT_Tc struct {
	Element
}

// TcPr returns the <w:tcPr> child element, or nil if not present.
func (e *CT_Tc) TcPr() *CT_TcPr {
	child := e.FindChild("w:tcPr")
	if child == nil {
		return nil
	}
	return &CT_TcPr{Element{E: child}}
}

// GetOrAddTcPr returns <w:tcPr>, creating it if not present.
func (e *CT_Tc) GetOrAddTcPr() *CT_TcPr {
	child := e.TcPr()
	if child != nil {
		return child
	}
	return e.addTcPr()
}

// RemoveTcPr removes all <w:tcPr> child elements.
func (e *CT_Tc) RemoveTcPr() {
	e.RemoveAll("w:tcPr")
}

// addTcPr adds a new <w:tcPr> in correct sequence.
func (e *CT_Tc) addTcPr() *CT_TcPr {
	child := e.newTcPr()
	e.insertTcPr(child)
	return child
}

// newTcPr creates a detached <w:tcPr> element.
func (e *CT_Tc) newTcPr() *CT_TcPr {
	el := OxmlElement("w:tcPr")
	return &CT_TcPr{Element{E: el}}
}

// insertTcPr inserts child before first successor.
func (e *CT_Tc) insertTcPr(child *CT_TcPr) *CT_TcPr {
	e.InsertElementBefore(child.E, "w:p", "w:tbl")
	return child
}

// PList returns all <w:p> child elements.
// At least one must be present in valid XML.
func (e *CT_Tc) PList() []*CT_P {
	children := e.FindAllChildren("w:p")
	result := make([]*CT_P, len(children))
	for i, c := range children {
		result[i] = &CT_P{Element{E: c}}
	}
	return result
}

// AddP adds a new <w:p> in correct sequence.
func (e *CT_Tc) AddP() *CT_P {
	return e.addP()
}

// addP adds a new <w:p> unconditionally in correct sequence.
func (e *CT_Tc) addP() *CT_P {
	child := e.newP()
	e.insertP(child)
	return child
}

// newP creates a detached <w:p> element.
func (e *CT_Tc) newP() *CT_P {
	el := OxmlElement("w:p")
	return &CT_P{Element{E: el}}
}

// insertP inserts child before first successor.
func (e *CT_Tc) insertP(child *CT_P) *CT_P {
	e.InsertElementBefore(child.E)
	return child
}

// TblList returns all <w:tbl> child elements.
// At least one must be present in valid XML.
func (e *CT_Tc) TblList() []*CT_Tbl {
	children := e.FindAllChildren("w:tbl")
	result := make([]*CT_Tbl, len(children))
	for i, c := range children {
		result[i] = &CT_Tbl{Element{E: c}}
	}
	return result
}

// AddTbl adds a new <w:tbl> in correct sequence.
func (e *CT_Tc) AddTbl() *CT_Tbl {
	return e.addTbl()
}

// addTbl adds a new <w:tbl> unconditionally in correct sequence.
func (e *CT_Tc) addTbl() *CT_Tbl {
	child := e.newTbl()
	e.insertTbl(child)
	return child
}

// newTbl creates a detached <w:tbl> element.
func (e *CT_Tc) newTbl() *CT_Tbl {
	el := OxmlElement("w:tbl")
	return &CT_Tbl{Element{E: el}}
}

// insertTbl inserts child before first successor.
func (e *CT_Tc) insertTbl(child *CT_Tbl) *CT_Tbl {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_TblPr ---

// CT_TblPr — table properties element
type CT_TblPr struct {
	Element
}

// TblStyle returns the <w:tblStyle> child element, or nil if not present.
func (e *CT_TblPr) TblStyle() *CT_String {
	child := e.FindChild("w:tblStyle")
	if child == nil {
		return nil
	}
	return &CT_String{Element{E: child}}
}

// GetOrAddTblStyle returns <w:tblStyle>, creating it if not present.
func (e *CT_TblPr) GetOrAddTblStyle() *CT_String {
	child := e.TblStyle()
	if child != nil {
		return child
	}
	return e.addTblStyle()
}

// RemoveTblStyle removes all <w:tblStyle> child elements.
func (e *CT_TblPr) RemoveTblStyle() {
	e.RemoveAll("w:tblStyle")
}

// addTblStyle adds a new <w:tblStyle> in correct sequence.
func (e *CT_TblPr) addTblStyle() *CT_String {
	child := e.newTblStyle()
	e.insertTblStyle(child)
	return child
}

// newTblStyle creates a detached <w:tblStyle> element.
func (e *CT_TblPr) newTblStyle() *CT_String {
	el := OxmlElement("w:tblStyle")
	return &CT_String{Element{E: el}}
}

// insertTblStyle inserts child before first successor.
func (e *CT_TblPr) insertTblStyle(child *CT_String) *CT_String {
	e.InsertElementBefore(child.E, "w:tblpPr", "w:tblOverlap", "w:bidiVisual", "w:tblStyleRowBandSize", "w:tblStyleColBandSize", "w:tblW", "w:jc", "w:tblCellSpacing", "w:tblInd", "w:tblBorders", "w:shd", "w:tblLayout", "w:tblCellMar", "w:tblLook", "w:tblCaption", "w:tblDescription", "w:tblPrChange")
	return child
}

// BidiVisual returns the <w:bidiVisual> child element, or nil if not present.
func (e *CT_TblPr) BidiVisual() *CT_OnOff {
	child := e.FindChild("w:bidiVisual")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddBidiVisual returns <w:bidiVisual>, creating it if not present.
func (e *CT_TblPr) GetOrAddBidiVisual() *CT_OnOff {
	child := e.BidiVisual()
	if child != nil {
		return child
	}
	return e.addBidiVisual()
}

// RemoveBidiVisual removes all <w:bidiVisual> child elements.
func (e *CT_TblPr) RemoveBidiVisual() {
	e.RemoveAll("w:bidiVisual")
}

// addBidiVisual adds a new <w:bidiVisual> in correct sequence.
func (e *CT_TblPr) addBidiVisual() *CT_OnOff {
	child := e.newBidiVisual()
	e.insertBidiVisual(child)
	return child
}

// newBidiVisual creates a detached <w:bidiVisual> element.
func (e *CT_TblPr) newBidiVisual() *CT_OnOff {
	el := OxmlElement("w:bidiVisual")
	return &CT_OnOff{Element{E: el}}
}

// insertBidiVisual inserts child before first successor.
func (e *CT_TblPr) insertBidiVisual(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:tblStyleRowBandSize", "w:tblStyleColBandSize", "w:tblW", "w:jc", "w:tblCellSpacing", "w:tblInd", "w:tblBorders", "w:shd", "w:tblLayout", "w:tblCellMar", "w:tblLook", "w:tblCaption", "w:tblDescription", "w:tblPrChange")
	return child
}

// Jc returns the <w:jc> child element, or nil if not present.
func (e *CT_TblPr) Jc() *CT_Jc {
	child := e.FindChild("w:jc")
	if child == nil {
		return nil
	}
	return &CT_Jc{Element{E: child}}
}

// GetOrAddJc returns <w:jc>, creating it if not present.
func (e *CT_TblPr) GetOrAddJc() *CT_Jc {
	child := e.Jc()
	if child != nil {
		return child
	}
	return e.addJc()
}

// RemoveJc removes all <w:jc> child elements.
func (e *CT_TblPr) RemoveJc() {
	e.RemoveAll("w:jc")
}

// addJc adds a new <w:jc> in correct sequence.
func (e *CT_TblPr) addJc() *CT_Jc {
	child := e.newJc()
	e.insertJc(child)
	return child
}

// newJc creates a detached <w:jc> element.
func (e *CT_TblPr) newJc() *CT_Jc {
	el := OxmlElement("w:jc")
	return &CT_Jc{Element{E: el}}
}

// insertJc inserts child before first successor.
func (e *CT_TblPr) insertJc(child *CT_Jc) *CT_Jc {
	e.InsertElementBefore(child.E, "w:tblCellSpacing", "w:tblInd", "w:tblBorders", "w:shd", "w:tblLayout", "w:tblCellMar", "w:tblLook", "w:tblCaption", "w:tblDescription", "w:tblPrChange")
	return child
}

// TblLayout returns the <w:tblLayout> child element, or nil if not present.
func (e *CT_TblPr) TblLayout() *CT_TblLayoutType {
	child := e.FindChild("w:tblLayout")
	if child == nil {
		return nil
	}
	return &CT_TblLayoutType{Element{E: child}}
}

// GetOrAddTblLayout returns <w:tblLayout>, creating it if not present.
func (e *CT_TblPr) GetOrAddTblLayout() *CT_TblLayoutType {
	child := e.TblLayout()
	if child != nil {
		return child
	}
	return e.addTblLayout()
}

// RemoveTblLayout removes all <w:tblLayout> child elements.
func (e *CT_TblPr) RemoveTblLayout() {
	e.RemoveAll("w:tblLayout")
}

// addTblLayout adds a new <w:tblLayout> in correct sequence.
func (e *CT_TblPr) addTblLayout() *CT_TblLayoutType {
	child := e.newTblLayout()
	e.insertTblLayout(child)
	return child
}

// newTblLayout creates a detached <w:tblLayout> element.
func (e *CT_TblPr) newTblLayout() *CT_TblLayoutType {
	el := OxmlElement("w:tblLayout")
	return &CT_TblLayoutType{Element{E: el}}
}

// insertTblLayout inserts child before first successor.
func (e *CT_TblPr) insertTblLayout(child *CT_TblLayoutType) *CT_TblLayoutType {
	e.InsertElementBefore(child.E, "w:tblCellMar", "w:tblLook", "w:tblCaption", "w:tblDescription", "w:tblPrChange")
	return child
}

// --- CT_TcPr ---

// CT_TcPr — table cell properties element
type CT_TcPr struct {
	Element
}

// TcW returns the <w:tcW> child element, or nil if not present.
func (e *CT_TcPr) TcW() *CT_TblWidth {
	child := e.FindChild("w:tcW")
	if child == nil {
		return nil
	}
	return &CT_TblWidth{Element{E: child}}
}

// GetOrAddTcW returns <w:tcW>, creating it if not present.
func (e *CT_TcPr) GetOrAddTcW() *CT_TblWidth {
	child := e.TcW()
	if child != nil {
		return child
	}
	return e.addTcW()
}

// RemoveTcW removes all <w:tcW> child elements.
func (e *CT_TcPr) RemoveTcW() {
	e.RemoveAll("w:tcW")
}

// addTcW adds a new <w:tcW> in correct sequence.
func (e *CT_TcPr) addTcW() *CT_TblWidth {
	child := e.newTcW()
	e.insertTcW(child)
	return child
}

// newTcW creates a detached <w:tcW> element.
func (e *CT_TcPr) newTcW() *CT_TblWidth {
	el := OxmlElement("w:tcW")
	return &CT_TblWidth{Element{E: el}}
}

// insertTcW inserts child before first successor.
func (e *CT_TcPr) insertTcW(child *CT_TblWidth) *CT_TblWidth {
	e.InsertElementBefore(child.E, "w:gridSpan", "w:hMerge", "w:vMerge", "w:tcBorders", "w:shd", "w:noWrap", "w:tcMar", "w:textDirection", "w:tcFitText", "w:vAlign", "w:hideMark", "w:headers", "w:cellIns", "w:cellDel", "w:cellMerge", "w:tcPrChange")
	return child
}

// GridSpan returns the <w:gridSpan> child element, or nil if not present.
func (e *CT_TcPr) GridSpan() *CT_DecimalNumber {
	child := e.FindChild("w:gridSpan")
	if child == nil {
		return nil
	}
	return &CT_DecimalNumber{Element{E: child}}
}

// GetOrAddGridSpan returns <w:gridSpan>, creating it if not present.
func (e *CT_TcPr) GetOrAddGridSpan() *CT_DecimalNumber {
	child := e.GridSpan()
	if child != nil {
		return child
	}
	return e.addGridSpan()
}

// RemoveGridSpan removes all <w:gridSpan> child elements.
func (e *CT_TcPr) RemoveGridSpan() {
	e.RemoveAll("w:gridSpan")
}

// addGridSpan adds a new <w:gridSpan> in correct sequence.
func (e *CT_TcPr) addGridSpan() *CT_DecimalNumber {
	child := e.newGridSpan()
	e.insertGridSpan(child)
	return child
}

// newGridSpan creates a detached <w:gridSpan> element.
func (e *CT_TcPr) newGridSpan() *CT_DecimalNumber {
	el := OxmlElement("w:gridSpan")
	return &CT_DecimalNumber{Element{E: el}}
}

// insertGridSpan inserts child before first successor.
func (e *CT_TcPr) insertGridSpan(child *CT_DecimalNumber) *CT_DecimalNumber {
	e.InsertElementBefore(child.E, "w:hMerge", "w:vMerge", "w:tcBorders", "w:shd", "w:noWrap", "w:tcMar", "w:textDirection", "w:tcFitText", "w:vAlign", "w:hideMark", "w:headers", "w:cellIns", "w:cellDel", "w:cellMerge", "w:tcPrChange")
	return child
}

// VMerge returns the <w:vMerge> child element, or nil if not present.
func (e *CT_TcPr) VMerge() *CT_VMerge {
	child := e.FindChild("w:vMerge")
	if child == nil {
		return nil
	}
	return &CT_VMerge{Element{E: child}}
}

// GetOrAddVMerge returns <w:vMerge>, creating it if not present.
func (e *CT_TcPr) GetOrAddVMerge() *CT_VMerge {
	child := e.VMerge()
	if child != nil {
		return child
	}
	return e.addVMerge()
}

// RemoveVMerge removes all <w:vMerge> child elements.
func (e *CT_TcPr) RemoveVMerge() {
	e.RemoveAll("w:vMerge")
}

// addVMerge adds a new <w:vMerge> in correct sequence.
func (e *CT_TcPr) addVMerge() *CT_VMerge {
	child := e.newVMerge()
	e.insertVMerge(child)
	return child
}

// newVMerge creates a detached <w:vMerge> element.
func (e *CT_TcPr) newVMerge() *CT_VMerge {
	el := OxmlElement("w:vMerge")
	return &CT_VMerge{Element{E: el}}
}

// insertVMerge inserts child before first successor.
func (e *CT_TcPr) insertVMerge(child *CT_VMerge) *CT_VMerge {
	e.InsertElementBefore(child.E, "w:tcBorders", "w:shd", "w:noWrap", "w:tcMar", "w:textDirection", "w:tcFitText", "w:vAlign", "w:hideMark", "w:headers", "w:cellIns", "w:cellDel", "w:cellMerge", "w:tcPrChange")
	return child
}

// VAlign returns the <w:vAlign> child element, or nil if not present.
func (e *CT_TcPr) VAlign() *CT_VerticalJc {
	child := e.FindChild("w:vAlign")
	if child == nil {
		return nil
	}
	return &CT_VerticalJc{Element{E: child}}
}

// GetOrAddVAlign returns <w:vAlign>, creating it if not present.
func (e *CT_TcPr) GetOrAddVAlign() *CT_VerticalJc {
	child := e.VAlign()
	if child != nil {
		return child
	}
	return e.addVAlign()
}

// RemoveVAlign removes all <w:vAlign> child elements.
func (e *CT_TcPr) RemoveVAlign() {
	e.RemoveAll("w:vAlign")
}

// addVAlign adds a new <w:vAlign> in correct sequence.
func (e *CT_TcPr) addVAlign() *CT_VerticalJc {
	child := e.newVAlign()
	e.insertVAlign(child)
	return child
}

// newVAlign creates a detached <w:vAlign> element.
func (e *CT_TcPr) newVAlign() *CT_VerticalJc {
	el := OxmlElement("w:vAlign")
	return &CT_VerticalJc{Element{E: el}}
}

// insertVAlign inserts child before first successor.
func (e *CT_TcPr) insertVAlign(child *CT_VerticalJc) *CT_VerticalJc {
	e.InsertElementBefore(child.E, "w:hideMark", "w:headers", "w:cellIns", "w:cellDel", "w:cellMerge", "w:tcPrChange")
	return child
}

// --- CT_TrPr ---

// CT_TrPr — table row properties element
type CT_TrPr struct {
	Element
}

// GridBefore returns the <w:gridBefore> child element, or nil if not present.
func (e *CT_TrPr) GridBefore() *CT_DecimalNumber {
	child := e.FindChild("w:gridBefore")
	if child == nil {
		return nil
	}
	return &CT_DecimalNumber{Element{E: child}}
}

// GetOrAddGridBefore returns <w:gridBefore>, creating it if not present.
func (e *CT_TrPr) GetOrAddGridBefore() *CT_DecimalNumber {
	child := e.GridBefore()
	if child != nil {
		return child
	}
	return e.addGridBefore()
}

// RemoveGridBefore removes all <w:gridBefore> child elements.
func (e *CT_TrPr) RemoveGridBefore() {
	e.RemoveAll("w:gridBefore")
}

// addGridBefore adds a new <w:gridBefore> in correct sequence.
func (e *CT_TrPr) addGridBefore() *CT_DecimalNumber {
	child := e.newGridBefore()
	e.insertGridBefore(child)
	return child
}

// newGridBefore creates a detached <w:gridBefore> element.
func (e *CT_TrPr) newGridBefore() *CT_DecimalNumber {
	el := OxmlElement("w:gridBefore")
	return &CT_DecimalNumber{Element{E: el}}
}

// insertGridBefore inserts child before first successor.
func (e *CT_TrPr) insertGridBefore(child *CT_DecimalNumber) *CT_DecimalNumber {
	e.InsertElementBefore(child.E, "w:gridAfter", "w:wBefore", "w:wAfter", "w:cantSplit", "w:trHeight", "w:tblHeader", "w:tblCellSpacing", "w:jc", "w:hidden", "w:ins", "w:del", "w:trPrChange")
	return child
}

// GridAfter returns the <w:gridAfter> child element, or nil if not present.
func (e *CT_TrPr) GridAfter() *CT_DecimalNumber {
	child := e.FindChild("w:gridAfter")
	if child == nil {
		return nil
	}
	return &CT_DecimalNumber{Element{E: child}}
}

// GetOrAddGridAfter returns <w:gridAfter>, creating it if not present.
func (e *CT_TrPr) GetOrAddGridAfter() *CT_DecimalNumber {
	child := e.GridAfter()
	if child != nil {
		return child
	}
	return e.addGridAfter()
}

// RemoveGridAfter removes all <w:gridAfter> child elements.
func (e *CT_TrPr) RemoveGridAfter() {
	e.RemoveAll("w:gridAfter")
}

// addGridAfter adds a new <w:gridAfter> in correct sequence.
func (e *CT_TrPr) addGridAfter() *CT_DecimalNumber {
	child := e.newGridAfter()
	e.insertGridAfter(child)
	return child
}

// newGridAfter creates a detached <w:gridAfter> element.
func (e *CT_TrPr) newGridAfter() *CT_DecimalNumber {
	el := OxmlElement("w:gridAfter")
	return &CT_DecimalNumber{Element{E: el}}
}

// insertGridAfter inserts child before first successor.
func (e *CT_TrPr) insertGridAfter(child *CT_DecimalNumber) *CT_DecimalNumber {
	e.InsertElementBefore(child.E, "w:wBefore", "w:wAfter", "w:cantSplit", "w:trHeight", "w:tblHeader", "w:tblCellSpacing", "w:jc", "w:hidden", "w:ins", "w:del", "w:trPrChange")
	return child
}

// TrHeight returns the <w:trHeight> child element, or nil if not present.
func (e *CT_TrPr) TrHeight() *CT_Height {
	child := e.FindChild("w:trHeight")
	if child == nil {
		return nil
	}
	return &CT_Height{Element{E: child}}
}

// GetOrAddTrHeight returns <w:trHeight>, creating it if not present.
func (e *CT_TrPr) GetOrAddTrHeight() *CT_Height {
	child := e.TrHeight()
	if child != nil {
		return child
	}
	return e.addTrHeight()
}

// RemoveTrHeight removes all <w:trHeight> child elements.
func (e *CT_TrPr) RemoveTrHeight() {
	e.RemoveAll("w:trHeight")
}

// addTrHeight adds a new <w:trHeight> in correct sequence.
func (e *CT_TrPr) addTrHeight() *CT_Height {
	child := e.newTrHeight()
	e.insertTrHeight(child)
	return child
}

// newTrHeight creates a detached <w:trHeight> element.
func (e *CT_TrPr) newTrHeight() *CT_Height {
	el := OxmlElement("w:trHeight")
	return &CT_Height{Element{E: el}}
}

// insertTrHeight inserts child before first successor.
func (e *CT_TrPr) insertTrHeight(child *CT_Height) *CT_Height {
	e.InsertElementBefore(child.E, "w:tblHeader", "w:tblCellSpacing", "w:jc", "w:hidden", "w:ins", "w:del", "w:trPrChange")
	return child
}

// --- CT_TblGrid ---

// CT_TblGrid — table grid element
type CT_TblGrid struct {
	Element
}

// GridColList returns all <w:gridCol> child elements.
func (e *CT_TblGrid) GridColList() []*CT_TblGridCol {
	children := e.FindAllChildren("w:gridCol")
	result := make([]*CT_TblGridCol, len(children))
	for i, c := range children {
		result[i] = &CT_TblGridCol{Element{E: c}}
	}
	return result
}

// AddGridCol adds a new <w:gridCol> in correct sequence.
func (e *CT_TblGrid) AddGridCol() *CT_TblGridCol {
	return e.addGridCol()
}

// addGridCol adds a new <w:gridCol> unconditionally in correct sequence.
func (e *CT_TblGrid) addGridCol() *CT_TblGridCol {
	child := e.newGridCol()
	e.insertGridCol(child)
	return child
}

// newGridCol creates a detached <w:gridCol> element.
func (e *CT_TblGrid) newGridCol() *CT_TblGridCol {
	el := OxmlElement("w:gridCol")
	return &CT_TblGridCol{Element{E: el}}
}

// insertGridCol inserts child before first successor.
func (e *CT_TblGrid) insertGridCol(child *CT_TblGridCol) *CT_TblGridCol {
	e.InsertElementBefore(child.E, "w:tblGridChange")
	return child
}

// --- CT_TblGridCol ---

// CT_TblGridCol — table grid column element
type CT_TblGridCol struct {
	Element
}

// W returns the value of the "w:w" attribute, or 0 if absent.
func (e *CT_TblGridCol) W() int {
	val, ok := e.GetAttr("w:w")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetW sets the "w:w" attribute.
// Passing 0 removes it.
func (e *CT_TblGridCol) SetW(v int) {
	if v == 0 {
		e.RemoveAttr("w:w")
		return
	}
	e.SetAttr("w:w", formatIntAttr(v))
}

// --- CT_Height ---

// CT_Height — row height element
type CT_Height struct {
	Element
}

// Val returns the value of the "w:val" attribute, or 0 if absent.
func (e *CT_Height) Val() int {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetVal sets the "w:val" attribute.
// Passing 0 removes it.
func (e *CT_Height) SetVal(v int) {
	if v == 0 {
		e.RemoveAttr("w:val")
		return
	}
	e.SetAttr("w:val", formatIntAttr(v))
}

// HRule returns the value of the "w:hRule" attribute, or enum.WdRowHeightRule(0) if absent.
func (e *CT_Height) HRule() enum.WdRowHeightRule {
	val, ok := e.GetAttr("w:hRule")
	if !ok {
		return enum.WdRowHeightRule(0)
	}
	return mustParseEnum(val, enum.WdRowHeightRuleFromXml)
}

// SetHRule sets the "w:hRule" attribute.
// Passing enum.WdRowHeightRule(0) removes it.
func (e *CT_Height) SetHRule(v enum.WdRowHeightRule) {
	if v == enum.WdRowHeightRule(0) {
		e.RemoveAttr("w:hRule")
		return
	}
	e.SetAttr("w:hRule", v.ToXml())
}

// --- CT_TblWidth ---

// CT_TblWidth — table width element
type CT_TblWidth struct {
	Element
}

// W returns the value of the required "w:w" attribute.
func (e *CT_TblWidth) W() (int, error) {
	val, ok := e.GetAttr("w:w")
	if !ok {
		return 0, fmt.Errorf("required attribute %q not present on <%s>", "w:w", e.Tag())
	}
	return parseIntAttr(val), nil
}

// SetW sets the required "w:w" attribute.
func (e *CT_TblWidth) SetW(v int) {
	e.SetAttr("w:w", formatIntAttr(v))
}

// Type returns the value of the required "w:type" attribute.
func (e *CT_TblWidth) Type() (string, error) {
	val, ok := e.GetAttr("w:type")
	if !ok {
		return "", fmt.Errorf("required attribute %q not present on <%s>", "w:type", e.Tag())
	}
	return val, nil
}

// SetType sets the required "w:type" attribute.
func (e *CT_TblWidth) SetType(v string) {
	e.SetAttr("w:type", v)
}

// --- CT_TblLayoutType ---

// CT_TblLayoutType — table layout type element
type CT_TblLayoutType struct {
	Element
}

// Type returns the value of the "w:type" attribute, or "" if absent.
func (e *CT_TblLayoutType) Type() string {
	val, ok := e.GetAttr("w:type")
	if !ok {
		return ""
	}
	return val
}

// SetType sets the "w:type" attribute.
// Passing "" removes it.
func (e *CT_TblLayoutType) SetType(v string) {
	if v == "" {
		e.RemoveAttr("w:type")
		return
	}
	e.SetAttr("w:type", v)
}

// --- CT_TblPrEx ---

// CT_TblPrEx — table property exceptions element
type CT_TblPrEx struct {
	Element
}

// --- CT_VerticalJc ---

// CT_VerticalJc — vertical alignment element
type CT_VerticalJc struct {
	Element
}

// Val returns the value of the required "w:val" attribute.
func (e *CT_VerticalJc) Val() (enum.WdCellVerticalAlignment, error) {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return enum.WdCellVerticalAlignment(0), fmt.Errorf("required attribute %q not present on <%s>", "w:val", e.Tag())
	}
	return mustParseEnum(val, enum.WdCellVerticalAlignmentFromXml), nil
}

// SetVal sets the required "w:val" attribute.
func (e *CT_VerticalJc) SetVal(v enum.WdCellVerticalAlignment) {
	e.SetAttr("w:val", v.ToXml())
}

// --- CT_VMerge ---

// CT_VMerge — vertical merge element
type CT_VMerge struct {
	Element
}

// Val returns the value of the "w:val" attribute, or "continue" if absent.
func (e *CT_VMerge) Val() string {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return "continue"
	}
	return val
}

// SetVal sets the "w:val" attribute.
// Passing "continue" removes it.
func (e *CT_VMerge) SetVal(v string) {
	if v == "continue" {
		e.RemoveAttr("w:val")
		return
	}
	e.SetAttr("w:val", v)
}
