// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_Document ---

// CT_Document — document root element
type CT_Document struct {
	Element
}

// Body returns the <w:body> child element, or nil if not present.
func (e *CT_Document) Body() *CT_Body {
	child := e.FindChild("w:body")
	if child == nil {
		return nil
	}
	return &CT_Body{Element{E: child}}
}

// GetOrAddBody returns <w:body>, creating it if not present.
func (e *CT_Document) GetOrAddBody() *CT_Body {
	child := e.Body()
	if child != nil {
		return child
	}
	return e.addBody()
}

// RemoveBody removes all <w:body> child elements.
func (e *CT_Document) RemoveBody() {
	e.RemoveAll("w:body")
}

// addBody adds a new <w:body> in correct sequence.
func (e *CT_Document) addBody() *CT_Body {
	child := e.newBody()
	e.insertBody(child)
	return child
}

// newBody creates a detached <w:body> element.
func (e *CT_Document) newBody() *CT_Body {
	el := OxmlElement("w:body")
	return &CT_Body{Element{E: el}}
}

// insertBody inserts child before first successor.
func (e *CT_Document) insertBody(child *CT_Body) *CT_Body {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_Body ---

// CT_Body — document body element
type CT_Body struct {
	Element
}

// SectPr returns the <w:sectPr> child element, or nil if not present.
func (e *CT_Body) SectPr() *CT_SectPr {
	child := e.FindChild("w:sectPr")
	if child == nil {
		return nil
	}
	return &CT_SectPr{Element{E: child}}
}

// GetOrAddSectPr returns <w:sectPr>, creating it if not present.
func (e *CT_Body) GetOrAddSectPr() *CT_SectPr {
	child := e.SectPr()
	if child != nil {
		return child
	}
	return e.addSectPr()
}

// RemoveSectPr removes all <w:sectPr> child elements.
func (e *CT_Body) RemoveSectPr() {
	e.RemoveAll("w:sectPr")
}

// addSectPr adds a new <w:sectPr> in correct sequence.
func (e *CT_Body) addSectPr() *CT_SectPr {
	child := e.newSectPr()
	e.insertSectPr(child)
	return child
}

// newSectPr creates a detached <w:sectPr> element.
func (e *CT_Body) newSectPr() *CT_SectPr {
	el := OxmlElement("w:sectPr")
	return &CT_SectPr{Element{E: el}}
}

// insertSectPr inserts child before first successor.
func (e *CT_Body) insertSectPr(child *CT_SectPr) *CT_SectPr {
	e.InsertElementBefore(child.E)
	return child
}

// PList returns all <w:p> child elements.
func (e *CT_Body) PList() []*CT_P {
	children := e.FindAllChildren("w:p")
	result := make([]*CT_P, len(children))
	for i, c := range children {
		result[i] = &CT_P{Element{E: c}}
	}
	return result
}

// AddP adds a new <w:p> in correct sequence.
func (e *CT_Body) AddP() *CT_P {
	return e.addP()
}

// addP adds a new <w:p> unconditionally in correct sequence.
func (e *CT_Body) addP() *CT_P {
	child := e.newP()
	e.insertP(child)
	return child
}

// newP creates a detached <w:p> element.
func (e *CT_Body) newP() *CT_P {
	el := OxmlElement("w:p")
	return &CT_P{Element{E: el}}
}

// insertP inserts child before first successor.
func (e *CT_Body) insertP(child *CT_P) *CT_P {
	e.InsertElementBefore(child.E, "w:sectPr")
	return child
}

// TblList returns all <w:tbl> child elements.
func (e *CT_Body) TblList() []*CT_Tbl {
	children := e.FindAllChildren("w:tbl")
	result := make([]*CT_Tbl, len(children))
	for i, c := range children {
		result[i] = &CT_Tbl{Element{E: c}}
	}
	return result
}

// AddTbl adds a new <w:tbl> in correct sequence.
func (e *CT_Body) AddTbl() *CT_Tbl {
	return e.addTbl()
}

// addTbl adds a new <w:tbl> unconditionally in correct sequence.
func (e *CT_Body) addTbl() *CT_Tbl {
	child := e.newTbl()
	e.insertTbl(child)
	return child
}

// newTbl creates a detached <w:tbl> element.
func (e *CT_Body) newTbl() *CT_Tbl {
	el := OxmlElement("w:tbl")
	return &CT_Tbl{Element{E: el}}
}

// insertTbl inserts child before first successor.
func (e *CT_Body) insertTbl(child *CT_Tbl) *CT_Tbl {
	e.InsertElementBefore(child.E, "w:sectPr")
	return child
}
