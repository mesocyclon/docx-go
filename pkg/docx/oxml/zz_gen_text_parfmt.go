// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
	"github.com/user/go-docx/pkg/docx/enum"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_PPr ---

// CT_PPr — paragraph properties element
type CT_PPr struct {
	Element
}

// PStyle returns the <w:pStyle> child element, or nil if not present.
func (e *CT_PPr) PStyle() *CT_String {
	child := e.FindChild("w:pStyle")
	if child == nil {
		return nil
	}
	return &CT_String{Element{E: child}}
}

// GetOrAddPStyle returns <w:pStyle>, creating it if not present.
func (e *CT_PPr) GetOrAddPStyle() *CT_String {
	child := e.PStyle()
	if child != nil {
		return child
	}
	return e.addPStyle()
}

// RemovePStyle removes all <w:pStyle> child elements.
func (e *CT_PPr) RemovePStyle() {
	e.RemoveAll("w:pStyle")
}

// addPStyle adds a new <w:pStyle> in correct sequence.
func (e *CT_PPr) addPStyle() *CT_String {
	child := e.newPStyle()
	e.insertPStyle(child)
	return child
}

// newPStyle creates a detached <w:pStyle> element.
func (e *CT_PPr) newPStyle() *CT_String {
	el := OxmlElement("w:pStyle")
	return &CT_String{Element{E: el}}
}

// insertPStyle inserts child before first successor.
func (e *CT_PPr) insertPStyle(child *CT_String) *CT_String {
	e.InsertElementBefore(child.E, "w:keepNext", "w:keepLines", "w:pageBreakBefore", "w:framePr", "w:widowControl", "w:numPr", "w:suppressLineNumbers", "w:pBdr", "w:shd", "w:tabs", "w:suppressAutoHyphens", "w:kinsoku", "w:wordWrap", "w:overflowPunct", "w:topLinePunct", "w:autoSpaceDE", "w:autoSpaceDN", "w:bidi", "w:adjustRightInd", "w:snapToGrid", "w:spacing", "w:ind", "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// KeepNext returns the <w:keepNext> child element, or nil if not present.
func (e *CT_PPr) KeepNext() *CT_OnOff {
	child := e.FindChild("w:keepNext")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddKeepNext returns <w:keepNext>, creating it if not present.
func (e *CT_PPr) GetOrAddKeepNext() *CT_OnOff {
	child := e.KeepNext()
	if child != nil {
		return child
	}
	return e.addKeepNext()
}

// RemoveKeepNext removes all <w:keepNext> child elements.
func (e *CT_PPr) RemoveKeepNext() {
	e.RemoveAll("w:keepNext")
}

// addKeepNext adds a new <w:keepNext> in correct sequence.
func (e *CT_PPr) addKeepNext() *CT_OnOff {
	child := e.newKeepNext()
	e.insertKeepNext(child)
	return child
}

// newKeepNext creates a detached <w:keepNext> element.
func (e *CT_PPr) newKeepNext() *CT_OnOff {
	el := OxmlElement("w:keepNext")
	return &CT_OnOff{Element{E: el}}
}

// insertKeepNext inserts child before first successor.
func (e *CT_PPr) insertKeepNext(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:keepLines", "w:pageBreakBefore", "w:framePr", "w:widowControl", "w:numPr", "w:suppressLineNumbers", "w:pBdr", "w:shd", "w:tabs", "w:suppressAutoHyphens", "w:kinsoku", "w:wordWrap", "w:overflowPunct", "w:topLinePunct", "w:autoSpaceDE", "w:autoSpaceDN", "w:bidi", "w:adjustRightInd", "w:snapToGrid", "w:spacing", "w:ind", "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// KeepLines returns the <w:keepLines> child element, or nil if not present.
func (e *CT_PPr) KeepLines() *CT_OnOff {
	child := e.FindChild("w:keepLines")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddKeepLines returns <w:keepLines>, creating it if not present.
func (e *CT_PPr) GetOrAddKeepLines() *CT_OnOff {
	child := e.KeepLines()
	if child != nil {
		return child
	}
	return e.addKeepLines()
}

// RemoveKeepLines removes all <w:keepLines> child elements.
func (e *CT_PPr) RemoveKeepLines() {
	e.RemoveAll("w:keepLines")
}

// addKeepLines adds a new <w:keepLines> in correct sequence.
func (e *CT_PPr) addKeepLines() *CT_OnOff {
	child := e.newKeepLines()
	e.insertKeepLines(child)
	return child
}

// newKeepLines creates a detached <w:keepLines> element.
func (e *CT_PPr) newKeepLines() *CT_OnOff {
	el := OxmlElement("w:keepLines")
	return &CT_OnOff{Element{E: el}}
}

// insertKeepLines inserts child before first successor.
func (e *CT_PPr) insertKeepLines(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:pageBreakBefore", "w:framePr", "w:widowControl", "w:numPr", "w:suppressLineNumbers", "w:pBdr", "w:shd", "w:tabs", "w:suppressAutoHyphens", "w:kinsoku", "w:wordWrap", "w:overflowPunct", "w:topLinePunct", "w:autoSpaceDE", "w:autoSpaceDN", "w:bidi", "w:adjustRightInd", "w:snapToGrid", "w:spacing", "w:ind", "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// PageBreakBefore returns the <w:pageBreakBefore> child element, or nil if not present.
func (e *CT_PPr) PageBreakBefore() *CT_OnOff {
	child := e.FindChild("w:pageBreakBefore")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddPageBreakBefore returns <w:pageBreakBefore>, creating it if not present.
func (e *CT_PPr) GetOrAddPageBreakBefore() *CT_OnOff {
	child := e.PageBreakBefore()
	if child != nil {
		return child
	}
	return e.addPageBreakBefore()
}

// RemovePageBreakBefore removes all <w:pageBreakBefore> child elements.
func (e *CT_PPr) RemovePageBreakBefore() {
	e.RemoveAll("w:pageBreakBefore")
}

// addPageBreakBefore adds a new <w:pageBreakBefore> in correct sequence.
func (e *CT_PPr) addPageBreakBefore() *CT_OnOff {
	child := e.newPageBreakBefore()
	e.insertPageBreakBefore(child)
	return child
}

// newPageBreakBefore creates a detached <w:pageBreakBefore> element.
func (e *CT_PPr) newPageBreakBefore() *CT_OnOff {
	el := OxmlElement("w:pageBreakBefore")
	return &CT_OnOff{Element{E: el}}
}

// insertPageBreakBefore inserts child before first successor.
func (e *CT_PPr) insertPageBreakBefore(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:framePr", "w:widowControl", "w:numPr", "w:suppressLineNumbers", "w:pBdr", "w:shd", "w:tabs", "w:suppressAutoHyphens", "w:kinsoku", "w:wordWrap", "w:overflowPunct", "w:topLinePunct", "w:autoSpaceDE", "w:autoSpaceDN", "w:bidi", "w:adjustRightInd", "w:snapToGrid", "w:spacing", "w:ind", "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// WidowControl returns the <w:widowControl> child element, or nil if not present.
func (e *CT_PPr) WidowControl() *CT_OnOff {
	child := e.FindChild("w:widowControl")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddWidowControl returns <w:widowControl>, creating it if not present.
func (e *CT_PPr) GetOrAddWidowControl() *CT_OnOff {
	child := e.WidowControl()
	if child != nil {
		return child
	}
	return e.addWidowControl()
}

// RemoveWidowControl removes all <w:widowControl> child elements.
func (e *CT_PPr) RemoveWidowControl() {
	e.RemoveAll("w:widowControl")
}

// addWidowControl adds a new <w:widowControl> in correct sequence.
func (e *CT_PPr) addWidowControl() *CT_OnOff {
	child := e.newWidowControl()
	e.insertWidowControl(child)
	return child
}

// newWidowControl creates a detached <w:widowControl> element.
func (e *CT_PPr) newWidowControl() *CT_OnOff {
	el := OxmlElement("w:widowControl")
	return &CT_OnOff{Element{E: el}}
}

// insertWidowControl inserts child before first successor.
func (e *CT_PPr) insertWidowControl(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:numPr", "w:suppressLineNumbers", "w:pBdr", "w:shd", "w:tabs", "w:suppressAutoHyphens", "w:kinsoku", "w:wordWrap", "w:overflowPunct", "w:topLinePunct", "w:autoSpaceDE", "w:autoSpaceDN", "w:bidi", "w:adjustRightInd", "w:snapToGrid", "w:spacing", "w:ind", "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// NumPr returns the <w:numPr> child element, or nil if not present.
func (e *CT_PPr) NumPr() *CT_NumPr {
	child := e.FindChild("w:numPr")
	if child == nil {
		return nil
	}
	return &CT_NumPr{Element{E: child}}
}

// GetOrAddNumPr returns <w:numPr>, creating it if not present.
func (e *CT_PPr) GetOrAddNumPr() *CT_NumPr {
	child := e.NumPr()
	if child != nil {
		return child
	}
	return e.addNumPr()
}

// RemoveNumPr removes all <w:numPr> child elements.
func (e *CT_PPr) RemoveNumPr() {
	e.RemoveAll("w:numPr")
}

// addNumPr adds a new <w:numPr> in correct sequence.
func (e *CT_PPr) addNumPr() *CT_NumPr {
	child := e.newNumPr()
	e.insertNumPr(child)
	return child
}

// newNumPr creates a detached <w:numPr> element.
func (e *CT_PPr) newNumPr() *CT_NumPr {
	el := OxmlElement("w:numPr")
	return &CT_NumPr{Element{E: el}}
}

// insertNumPr inserts child before first successor.
func (e *CT_PPr) insertNumPr(child *CT_NumPr) *CT_NumPr {
	e.InsertElementBefore(child.E, "w:suppressLineNumbers", "w:pBdr", "w:shd", "w:tabs", "w:suppressAutoHyphens", "w:kinsoku", "w:wordWrap", "w:overflowPunct", "w:topLinePunct", "w:autoSpaceDE", "w:autoSpaceDN", "w:bidi", "w:adjustRightInd", "w:snapToGrid", "w:spacing", "w:ind", "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// Tabs returns the <w:tabs> child element, or nil if not present.
func (e *CT_PPr) Tabs() *CT_TabStops {
	child := e.FindChild("w:tabs")
	if child == nil {
		return nil
	}
	return &CT_TabStops{Element{E: child}}
}

// GetOrAddTabs returns <w:tabs>, creating it if not present.
func (e *CT_PPr) GetOrAddTabs() *CT_TabStops {
	child := e.Tabs()
	if child != nil {
		return child
	}
	return e.addTabs()
}

// RemoveTabs removes all <w:tabs> child elements.
func (e *CT_PPr) RemoveTabs() {
	e.RemoveAll("w:tabs")
}

// addTabs adds a new <w:tabs> in correct sequence.
func (e *CT_PPr) addTabs() *CT_TabStops {
	child := e.newTabs()
	e.insertTabs(child)
	return child
}

// newTabs creates a detached <w:tabs> element.
func (e *CT_PPr) newTabs() *CT_TabStops {
	el := OxmlElement("w:tabs")
	return &CT_TabStops{Element{E: el}}
}

// insertTabs inserts child before first successor.
func (e *CT_PPr) insertTabs(child *CT_TabStops) *CT_TabStops {
	e.InsertElementBefore(child.E, "w:suppressAutoHyphens", "w:kinsoku", "w:wordWrap", "w:overflowPunct", "w:topLinePunct", "w:autoSpaceDE", "w:autoSpaceDN", "w:bidi", "w:adjustRightInd", "w:snapToGrid", "w:spacing", "w:ind", "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// Spacing returns the <w:spacing> child element, or nil if not present.
func (e *CT_PPr) Spacing() *CT_Spacing {
	child := e.FindChild("w:spacing")
	if child == nil {
		return nil
	}
	return &CT_Spacing{Element{E: child}}
}

// GetOrAddSpacing returns <w:spacing>, creating it if not present.
func (e *CT_PPr) GetOrAddSpacing() *CT_Spacing {
	child := e.Spacing()
	if child != nil {
		return child
	}
	return e.addSpacing()
}

// RemoveSpacing removes all <w:spacing> child elements.
func (e *CT_PPr) RemoveSpacing() {
	e.RemoveAll("w:spacing")
}

// addSpacing adds a new <w:spacing> in correct sequence.
func (e *CT_PPr) addSpacing() *CT_Spacing {
	child := e.newSpacing()
	e.insertSpacing(child)
	return child
}

// newSpacing creates a detached <w:spacing> element.
func (e *CT_PPr) newSpacing() *CT_Spacing {
	el := OxmlElement("w:spacing")
	return &CT_Spacing{Element{E: el}}
}

// insertSpacing inserts child before first successor.
func (e *CT_PPr) insertSpacing(child *CT_Spacing) *CT_Spacing {
	e.InsertElementBefore(child.E, "w:ind", "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// Ind returns the <w:ind> child element, or nil if not present.
func (e *CT_PPr) Ind() *CT_Ind {
	child := e.FindChild("w:ind")
	if child == nil {
		return nil
	}
	return &CT_Ind{Element{E: child}}
}

// GetOrAddInd returns <w:ind>, creating it if not present.
func (e *CT_PPr) GetOrAddInd() *CT_Ind {
	child := e.Ind()
	if child != nil {
		return child
	}
	return e.addInd()
}

// RemoveInd removes all <w:ind> child elements.
func (e *CT_PPr) RemoveInd() {
	e.RemoveAll("w:ind")
}

// addInd adds a new <w:ind> in correct sequence.
func (e *CT_PPr) addInd() *CT_Ind {
	child := e.newInd()
	e.insertInd(child)
	return child
}

// newInd creates a detached <w:ind> element.
func (e *CT_PPr) newInd() *CT_Ind {
	el := OxmlElement("w:ind")
	return &CT_Ind{Element{E: el}}
}

// insertInd inserts child before first successor.
func (e *CT_PPr) insertInd(child *CT_Ind) *CT_Ind {
	e.InsertElementBefore(child.E, "w:contextualSpacing", "w:mirrorIndents", "w:suppressOverlap", "w:jc", "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// Jc returns the <w:jc> child element, or nil if not present.
func (e *CT_PPr) Jc() *CT_Jc {
	child := e.FindChild("w:jc")
	if child == nil {
		return nil
	}
	return &CT_Jc{Element{E: child}}
}

// GetOrAddJc returns <w:jc>, creating it if not present.
func (e *CT_PPr) GetOrAddJc() *CT_Jc {
	child := e.Jc()
	if child != nil {
		return child
	}
	return e.addJc()
}

// RemoveJc removes all <w:jc> child elements.
func (e *CT_PPr) RemoveJc() {
	e.RemoveAll("w:jc")
}

// addJc adds a new <w:jc> in correct sequence.
func (e *CT_PPr) addJc() *CT_Jc {
	child := e.newJc()
	e.insertJc(child)
	return child
}

// newJc creates a detached <w:jc> element.
func (e *CT_PPr) newJc() *CT_Jc {
	el := OxmlElement("w:jc")
	return &CT_Jc{Element{E: el}}
}

// insertJc inserts child before first successor.
func (e *CT_PPr) insertJc(child *CT_Jc) *CT_Jc {
	e.InsertElementBefore(child.E, "w:textDirection", "w:textAlignment", "w:textboxTightWrap", "w:outlineLvl", "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// OutlineLvl returns the <w:outlineLvl> child element, or nil if not present.
func (e *CT_PPr) OutlineLvl() *CT_DecimalNumber {
	child := e.FindChild("w:outlineLvl")
	if child == nil {
		return nil
	}
	return &CT_DecimalNumber{Element{E: child}}
}

// GetOrAddOutlineLvl returns <w:outlineLvl>, creating it if not present.
func (e *CT_PPr) GetOrAddOutlineLvl() *CT_DecimalNumber {
	child := e.OutlineLvl()
	if child != nil {
		return child
	}
	return e.addOutlineLvl()
}

// RemoveOutlineLvl removes all <w:outlineLvl> child elements.
func (e *CT_PPr) RemoveOutlineLvl() {
	e.RemoveAll("w:outlineLvl")
}

// addOutlineLvl adds a new <w:outlineLvl> in correct sequence.
func (e *CT_PPr) addOutlineLvl() *CT_DecimalNumber {
	child := e.newOutlineLvl()
	e.insertOutlineLvl(child)
	return child
}

// newOutlineLvl creates a detached <w:outlineLvl> element.
func (e *CT_PPr) newOutlineLvl() *CT_DecimalNumber {
	el := OxmlElement("w:outlineLvl")
	return &CT_DecimalNumber{Element{E: el}}
}

// insertOutlineLvl inserts child before first successor.
func (e *CT_PPr) insertOutlineLvl(child *CT_DecimalNumber) *CT_DecimalNumber {
	e.InsertElementBefore(child.E, "w:divId", "w:cnfStyle", "w:rPr", "w:sectPr", "w:pPrChange")
	return child
}

// SectPr returns the <w:sectPr> child element, or nil if not present.
func (e *CT_PPr) SectPr() *CT_SectPr {
	child := e.FindChild("w:sectPr")
	if child == nil {
		return nil
	}
	return &CT_SectPr{Element{E: child}}
}

// GetOrAddSectPr returns <w:sectPr>, creating it if not present.
func (e *CT_PPr) GetOrAddSectPr() *CT_SectPr {
	child := e.SectPr()
	if child != nil {
		return child
	}
	return e.addSectPr()
}

// RemoveSectPr removes all <w:sectPr> child elements.
func (e *CT_PPr) RemoveSectPr() {
	e.RemoveAll("w:sectPr")
}

// addSectPr adds a new <w:sectPr> in correct sequence.
func (e *CT_PPr) addSectPr() *CT_SectPr {
	child := e.newSectPr()
	e.insertSectPr(child)
	return child
}

// newSectPr creates a detached <w:sectPr> element.
func (e *CT_PPr) newSectPr() *CT_SectPr {
	el := OxmlElement("w:sectPr")
	return &CT_SectPr{Element{E: el}}
}

// insertSectPr inserts child before first successor.
func (e *CT_PPr) insertSectPr(child *CT_SectPr) *CT_SectPr {
	e.InsertElementBefore(child.E, "w:pPrChange")
	return child
}

// --- CT_Ind ---

// CT_Ind — indentation element
type CT_Ind struct {
	Element
}

// Left returns the value of the "w:left" attribute, or 0 if absent.
func (e *CT_Ind) Left() int {
	val, ok := e.GetAttr("w:left")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetLeft sets the "w:left" attribute.
// Passing 0 removes it.
func (e *CT_Ind) SetLeft(v int) {
	if v == 0 {
		e.RemoveAttr("w:left")
		return
	}
	e.SetAttr("w:left", formatIntAttr(v))
}

// Right returns the value of the "w:right" attribute, or 0 if absent.
func (e *CT_Ind) Right() int {
	val, ok := e.GetAttr("w:right")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetRight sets the "w:right" attribute.
// Passing 0 removes it.
func (e *CT_Ind) SetRight(v int) {
	if v == 0 {
		e.RemoveAttr("w:right")
		return
	}
	e.SetAttr("w:right", formatIntAttr(v))
}

// FirstLine returns the value of the "w:firstLine" attribute, or 0 if absent.
func (e *CT_Ind) FirstLine() int {
	val, ok := e.GetAttr("w:firstLine")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetFirstLine sets the "w:firstLine" attribute.
// Passing 0 removes it.
func (e *CT_Ind) SetFirstLine(v int) {
	if v == 0 {
		e.RemoveAttr("w:firstLine")
		return
	}
	e.SetAttr("w:firstLine", formatIntAttr(v))
}

// Hanging returns the value of the "w:hanging" attribute, or 0 if absent.
func (e *CT_Ind) Hanging() int {
	val, ok := e.GetAttr("w:hanging")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetHanging sets the "w:hanging" attribute.
// Passing 0 removes it.
func (e *CT_Ind) SetHanging(v int) {
	if v == 0 {
		e.RemoveAttr("w:hanging")
		return
	}
	e.SetAttr("w:hanging", formatIntAttr(v))
}

// --- CT_Jc ---

// CT_Jc — justification element
type CT_Jc struct {
	Element
}

// Val returns the value of the required "w:val" attribute.
func (e *CT_Jc) Val() (enum.WdParagraphAlignment, error) {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return enum.WdParagraphAlignment(0), fmt.Errorf("required attribute %q not present on <%s>", "w:val", e.Tag())
	}
	return mustParseEnum(val, enum.WdParagraphAlignmentFromXml), nil
}

// SetVal sets the required "w:val" attribute.
func (e *CT_Jc) SetVal(v enum.WdParagraphAlignment) {
	e.SetAttr("w:val", v.ToXml())
}

// --- CT_Spacing ---

// CT_Spacing — spacing element
type CT_Spacing struct {
	Element
}

// After returns the value of the "w:after" attribute, or 0 if absent.
func (e *CT_Spacing) After() int {
	val, ok := e.GetAttr("w:after")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetAfter sets the "w:after" attribute.
// Passing 0 removes it.
func (e *CT_Spacing) SetAfter(v int) {
	if v == 0 {
		e.RemoveAttr("w:after")
		return
	}
	e.SetAttr("w:after", formatIntAttr(v))
}

// Before returns the value of the "w:before" attribute, or 0 if absent.
func (e *CT_Spacing) Before() int {
	val, ok := e.GetAttr("w:before")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetBefore sets the "w:before" attribute.
// Passing 0 removes it.
func (e *CT_Spacing) SetBefore(v int) {
	if v == 0 {
		e.RemoveAttr("w:before")
		return
	}
	e.SetAttr("w:before", formatIntAttr(v))
}

// Line returns the value of the "w:line" attribute, or 0 if absent.
func (e *CT_Spacing) Line() int {
	val, ok := e.GetAttr("w:line")
	if !ok {
		return 0
	}
	return parseIntAttr(val)
}

// SetLine sets the "w:line" attribute.
// Passing 0 removes it.
func (e *CT_Spacing) SetLine(v int) {
	if v == 0 {
		e.RemoveAttr("w:line")
		return
	}
	e.SetAttr("w:line", formatIntAttr(v))
}

// LineRule returns the value of the "w:lineRule" attribute, or "" if absent.
func (e *CT_Spacing) LineRule() string {
	val, ok := e.GetAttr("w:lineRule")
	if !ok {
		return ""
	}
	return val
}

// SetLineRule sets the "w:lineRule" attribute.
// Passing "" removes it.
func (e *CT_Spacing) SetLineRule(v string) {
	if v == "" {
		e.RemoveAttr("w:lineRule")
		return
	}
	e.SetAttr("w:lineRule", v)
}

// --- CT_TabStop ---

// CT_TabStop — tab stop element
type CT_TabStop struct {
	Element
}

// Leader returns the value of the "w:leader" attribute, or enum.WdTabLeader(0) if absent.
func (e *CT_TabStop) Leader() enum.WdTabLeader {
	val, ok := e.GetAttr("w:leader")
	if !ok {
		return enum.WdTabLeader(0)
	}
	return mustParseEnum(val, enum.WdTabLeaderFromXml)
}

// SetLeader sets the "w:leader" attribute.
// Passing enum.WdTabLeader(0) removes it.
func (e *CT_TabStop) SetLeader(v enum.WdTabLeader) {
	if v == enum.WdTabLeader(0) {
		e.RemoveAttr("w:leader")
		return
	}
	e.SetAttr("w:leader", v.ToXml())
}

// Val returns the value of the required "w:val" attribute.
func (e *CT_TabStop) Val() (enum.WdTabAlignment, error) {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return enum.WdTabAlignment(0), fmt.Errorf("required attribute %q not present on <%s>", "w:val", e.Tag())
	}
	return mustParseEnum(val, enum.WdTabAlignmentFromXml), nil
}

// SetVal sets the required "w:val" attribute.
func (e *CT_TabStop) SetVal(v enum.WdTabAlignment) {
	e.SetAttr("w:val", v.ToXml())
}

// Pos returns the value of the required "w:pos" attribute.
func (e *CT_TabStop) Pos() (int, error) {
	val, ok := e.GetAttr("w:pos")
	if !ok {
		return 0, fmt.Errorf("required attribute %q not present on <%s>", "w:pos", e.Tag())
	}
	return parseIntAttr(val), nil
}

// SetPos sets the required "w:pos" attribute.
func (e *CT_TabStop) SetPos(v int) {
	e.SetAttr("w:pos", formatIntAttr(v))
}

// --- CT_TabStops ---

// CT_TabStops — tab stops container element
type CT_TabStops struct {
	Element
}

// TabList returns all <w:tab> child elements.
// At least one must be present in valid XML.
func (e *CT_TabStops) TabList() []*CT_TabStop {
	children := e.FindAllChildren("w:tab")
	result := make([]*CT_TabStop, len(children))
	for i, c := range children {
		result[i] = &CT_TabStop{Element{E: c}}
	}
	return result
}

// AddTab adds a new <w:tab> in correct sequence.
func (e *CT_TabStops) AddTab() *CT_TabStop {
	return e.addTab()
}

// addTab adds a new <w:tab> unconditionally in correct sequence.
func (e *CT_TabStops) addTab() *CT_TabStop {
	child := e.newTab()
	e.insertTab(child)
	return child
}

// newTab creates a detached <w:tab> element.
func (e *CT_TabStops) newTab() *CT_TabStop {
	el := OxmlElement("w:tab")
	return &CT_TabStop{Element{E: el}}
}

// insertTab inserts child before first successor.
func (e *CT_TabStops) insertTab(child *CT_TabStop) *CT_TabStop {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_NumPr ---

// CT_NumPr — numbering properties element
type CT_NumPr struct {
	Element
}

// Ilvl returns the <w:ilvl> child element, or nil if not present.
func (e *CT_NumPr) Ilvl() *CT_DecimalNumber {
	child := e.FindChild("w:ilvl")
	if child == nil {
		return nil
	}
	return &CT_DecimalNumber{Element{E: child}}
}

// GetOrAddIlvl returns <w:ilvl>, creating it if not present.
func (e *CT_NumPr) GetOrAddIlvl() *CT_DecimalNumber {
	child := e.Ilvl()
	if child != nil {
		return child
	}
	return e.addIlvl()
}

// RemoveIlvl removes all <w:ilvl> child elements.
func (e *CT_NumPr) RemoveIlvl() {
	e.RemoveAll("w:ilvl")
}

// addIlvl adds a new <w:ilvl> in correct sequence.
func (e *CT_NumPr) addIlvl() *CT_DecimalNumber {
	child := e.newIlvl()
	e.insertIlvl(child)
	return child
}

// newIlvl creates a detached <w:ilvl> element.
func (e *CT_NumPr) newIlvl() *CT_DecimalNumber {
	el := OxmlElement("w:ilvl")
	return &CT_DecimalNumber{Element{E: el}}
}

// insertIlvl inserts child before first successor.
func (e *CT_NumPr) insertIlvl(child *CT_DecimalNumber) *CT_DecimalNumber {
	e.InsertElementBefore(child.E, "w:numId", "w:numberingChange", "w:ins")
	return child
}

// NumId returns the <w:numId> child element, or nil if not present.
func (e *CT_NumPr) NumId() *CT_DecimalNumber {
	child := e.FindChild("w:numId")
	if child == nil {
		return nil
	}
	return &CT_DecimalNumber{Element{E: child}}
}

// GetOrAddNumId returns <w:numId>, creating it if not present.
func (e *CT_NumPr) GetOrAddNumId() *CT_DecimalNumber {
	child := e.NumId()
	if child != nil {
		return child
	}
	return e.addNumId()
}

// RemoveNumId removes all <w:numId> child elements.
func (e *CT_NumPr) RemoveNumId() {
	e.RemoveAll("w:numId")
}

// addNumId adds a new <w:numId> in correct sequence.
func (e *CT_NumPr) addNumId() *CT_DecimalNumber {
	child := e.newNumId()
	e.insertNumId(child)
	return child
}

// newNumId creates a detached <w:numId> element.
func (e *CT_NumPr) newNumId() *CT_DecimalNumber {
	el := OxmlElement("w:numId")
	return &CT_DecimalNumber{Element{E: el}}
}

// insertNumId inserts child before first successor.
func (e *CT_NumPr) insertNumId(child *CT_DecimalNumber) *CT_DecimalNumber {
	e.InsertElementBefore(child.E, "w:numberingChange", "w:ins")
	return child
}
