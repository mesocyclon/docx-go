// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_Comments ---

// CT_Comments — comments root element
type CT_Comments struct {
	Element
}

// CommentList returns all <w:comment> child elements.
func (e *CT_Comments) CommentList() []*CT_Comment {
	children := e.FindAllChildren("w:comment")
	result := make([]*CT_Comment, len(children))
	for i, c := range children {
		result[i] = &CT_Comment{Element{E: c}}
	}
	return result
}

// AddComment adds a new <w:comment> in correct sequence.
func (e *CT_Comments) AddComment() *CT_Comment {
	return e.addComment()
}

// addComment adds a new <w:comment> unconditionally in correct sequence.
func (e *CT_Comments) addComment() *CT_Comment {
	child := e.newComment()
	e.insertComment(child)
	return child
}

// newComment creates a detached <w:comment> element.
func (e *CT_Comments) newComment() *CT_Comment {
	el := OxmlElement("w:comment")
	return &CT_Comment{Element{E: el}}
}

// insertComment inserts child before first successor.
func (e *CT_Comments) insertComment(child *CT_Comment) *CT_Comment {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_Comment ---

// CT_Comment — comment element
type CT_Comment struct {
	Element
}

// PList returns all <w:p> child elements.
func (e *CT_Comment) PList() []*CT_P {
	children := e.FindAllChildren("w:p")
	result := make([]*CT_P, len(children))
	for i, c := range children {
		result[i] = &CT_P{Element{E: c}}
	}
	return result
}

// AddP adds a new <w:p> in correct sequence.
func (e *CT_Comment) AddP() *CT_P {
	return e.addP()
}

// addP adds a new <w:p> unconditionally in correct sequence.
func (e *CT_Comment) addP() *CT_P {
	child := e.newP()
	e.insertP(child)
	return child
}

// newP creates a detached <w:p> element.
func (e *CT_Comment) newP() *CT_P {
	el := OxmlElement("w:p")
	return &CT_P{Element{E: el}}
}

// insertP inserts child before first successor.
func (e *CT_Comment) insertP(child *CT_P) *CT_P {
	e.InsertElementBefore(child.E)
	return child
}

// TblList returns all <w:tbl> child elements.
func (e *CT_Comment) TblList() []*CT_Tbl {
	children := e.FindAllChildren("w:tbl")
	result := make([]*CT_Tbl, len(children))
	for i, c := range children {
		result[i] = &CT_Tbl{Element{E: c}}
	}
	return result
}

// AddTbl adds a new <w:tbl> in correct sequence.
func (e *CT_Comment) AddTbl() *CT_Tbl {
	return e.addTbl()
}

// addTbl adds a new <w:tbl> unconditionally in correct sequence.
func (e *CT_Comment) addTbl() *CT_Tbl {
	child := e.newTbl()
	e.insertTbl(child)
	return child
}

// newTbl creates a detached <w:tbl> element.
func (e *CT_Comment) newTbl() *CT_Tbl {
	el := OxmlElement("w:tbl")
	return &CT_Tbl{Element{E: el}}
}

// insertTbl inserts child before first successor.
func (e *CT_Comment) insertTbl(child *CT_Tbl) *CT_Tbl {
	e.InsertElementBefore(child.E)
	return child
}

// Initials returns the value of the "w:initials" attribute, or "" if absent.
func (e *CT_Comment) Initials() string {
	val, ok := e.GetAttr("w:initials")
	if !ok {
		return ""
	}
	return val
}

// SetInitials sets the "w:initials" attribute.
// Passing "" removes it.
func (e *CT_Comment) SetInitials(v string) {
	if v == "" {
		e.RemoveAttr("w:initials")
		return
	}
	e.SetAttr("w:initials", v)
}

// Date returns the value of the "w:date" attribute, or "" if absent.
func (e *CT_Comment) Date() string {
	val, ok := e.GetAttr("w:date")
	if !ok {
		return ""
	}
	return val
}

// SetDate sets the "w:date" attribute.
// Passing "" removes it.
func (e *CT_Comment) SetDate(v string) {
	if v == "" {
		e.RemoveAttr("w:date")
		return
	}
	e.SetAttr("w:date", v)
}

// Id returns the value of the required "w:id" attribute.
func (e *CT_Comment) Id() (int, error) {
	val, ok := e.GetAttr("w:id")
	if !ok {
		return 0, fmt.Errorf("required attribute %q not present on <%s>", "w:id", e.Tag())
	}
	return parseIntAttr(val), nil
}

// SetId sets the required "w:id" attribute.
func (e *CT_Comment) SetId(v int) {
	e.SetAttr("w:id", formatIntAttr(v))
}

// Author returns the value of the required "w:author" attribute.
func (e *CT_Comment) Author() (string, error) {
	val, ok := e.GetAttr("w:author")
	if !ok {
		return "", fmt.Errorf("required attribute %q not present on <%s>", "w:author", e.Tag())
	}
	return val, nil
}

// SetAuthor sets the required "w:author" attribute.
func (e *CT_Comment) SetAuthor(v string) {
	e.SetAttr("w:author", v)
}
